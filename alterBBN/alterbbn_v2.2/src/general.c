#include "include.h"

/*-----------------------------------------------------------------------*/
/* Exponential integral Ei */
/*-----------------------------------------------------------------------*/

double Ei1(double x)
{
	double epsilon=1.e-10;
	double Am1=1.;
	double A0=0.;
	double Bm1=0.;
	double B0=1.;
	double a=exp(x);
	double b=-x+1.;
	double Ap1=b*A0+a*Am1;
	double Bp1=b*B0+a*Bm1;
	int j=1;

	a=1.;
	while(fabs(Ap1*B0-A0*Bp1)>epsilon*fabs(A0*Bp1))
	{
		if(fabs(Bp1)>1.)
		{
			Am1=A0/Bp1;
			A0=Ap1/Bp1;
			Bm1=B0/Bp1;
			B0=1.;
      		} 
		else 
		{
         		Am1=A0;
         		A0=Ap1;
         		Bm1=B0;
         		B0=Bp1;
		}
		a=-j*j;
		b+=2.;
		Ap1=b*A0+a*Am1;
		Bp1=b*B0+a*Bm1;
		j+=1;
	}
	
	return (-Ap1/Bp1);
}

double Ei2(double x)
{ 
	double epsilon=1.e-10;
	double xn=-x;
	double Sn=-x;
	double Sm1=0.;
	double hsum =1.;
	double g=0.5772156649015328606065121;
	double y=1.;
	double factorial=1.;
  
	while(fabs(Sn-Sm1)>epsilon*fabs(Sm1))
	{
		Sm1=Sn;
		y+=1.;
		xn*=(-x);
		factorial*=y;
		hsum+=1./y;
		Sn+=hsum*xn/factorial;
	}
	
	return(g+log(fabs(x))-exp(x)*Sn);
}

double Ei3(double x)
{
	double ei[]={
	1.915047433355013959531e2,  4.403798995348382689974e2,
	1.037878290717089587658e3,  2.492228976241877759138e3,
	6.071406374098611507965e3,  1.495953266639752885229e4,
	3.719768849068903560439e4,  9.319251363396537129882e4,
	2.349558524907683035782e5,  5.955609986708370018502e5,
	1.516637894042516884433e6,  3.877904330597443502996e6,
	9.950907251046844760026e6,  2.561565266405658882048e7,
	6.612718635548492136250e7,  1.711446713003636684975e8,
	4.439663698302712208698e8,  1.154115391849182948287e9,
	3.005950906525548689841e9,  7.842940991898186370453e9,
	2.049649711988081236484e10, 5.364511859231469415605e10,
	1.405991957584069047340e11, 3.689732094072741970640e11,
	9.694555759683939661662e11, 2.550043566357786926147e12,
	6.714640184076497558707e12, 1.769803724411626854310e13,
	4.669055014466159544500e13, 1.232852079912097685431e14,
	3.257988998672263996790e14, 8.616388199965786544948e14,
	2.280446200301902595341e15, 6.039718263611241578359e15,
	1.600664914324504111070e16, 4.244796092136850759368e16,
	1.126348290166966760275e17, 2.990444718632336675058e17,
	7.943916035704453771510e17, 2.111342388647824195000e18,
	5.614329680810343111535e18, 1.493630213112993142255e19,
	3.975442747903744836007e19, 1.058563689713169096306e20
	};
	
	double epsilon=1.e-10;
	int k=(int)(x+0.5);
	int j=0;
	double xx=(double)k;
	double dx=x-xx;
	double xxj=xx;
	double edx=exp(dx);
	double Sm=1.;
	double Sn=(edx-1.)/xxj;
	double term=exp(100.);
	double factorial=1.;
	double dxj=1.;

	while (term>epsilon*fabs(Sn))
	{
		j++;
		factorial*=(double)j;
		xxj*=xx;
		dxj*=(-dx);
		Sm+=(dxj/factorial);
		term=(factorial*(edx*Sm-1.))/xxj;
		Sn+=term;
	}
   
	return ei[k-7]+Sn*exp(xx); 
}


double Ei(double x)
{
	if(x<-5.) return Ei1(x);
	if(x<6.8)  return Ei2(x);
	if(x<50.) return Ei3(x);
	return Ei1(x);
}

/*--------------------------------------------------------------------*/

double complex polylog(int n, int m, double x)
{
	double complex z,v[6],sk,sj;

        int fct[5]={1,1,2,6,24};
	int sgn[5]={1,-1,1,-1,1};
	int index[32]={0,1,2,3,4,0,0,0,0,0,0,5,6,7,0,0,0,0,0,0,0,8,9,0,0,0,0,0,0,0,0,10};
	int nc[11]={0,24,26,28,30,22,24,26,19,22,17};
	
	double u[5],s1[5][5],c[5][5],a[31][11];
      	double z0=0.;
	double z1=1.;
	double hf=z1/2.;
	double c1=4.*z1/3.;
	double c2=z1/3.;

	double x1,h,alfa;
	int je,ke,le;
	int m1,n1,it;
	double q,r,b1,b2,b0;
	
	s1[1][1]=1.6449340668482;
	s1[1][2]=1.2020569031596;
	s1[1][3]=1.0823232337111;
	s1[1][4]=1.0369277551434;
	s1[2][1]=1.2020569031596;
	s1[2][2]=2.7058080842778e-1;
	s1[2][3]=9.6551159989444e-2;
	s1[3][1]=1.0823232337111;
	s1[3][2]=9.6551159989444e-2;
	s1[4][1]=1.0369277551434;
	c[1][1]=1.6449340668482;
	c[1][2]=1.2020569031596;
	c[1][3]=1.0823232337111;
	c[1][4]=1.0369277551434;
	c[2][1]=0.0000000000000;
	c[2][2]=-1.8940656589945;
	c[2][3]=-3.0142321054407;
	c[3][1]=1.8940656589945;
	c[3][2]=3.0142321054407;
	c[4][1]=0.0000000000000;
	a[0][1]=.96753215043498;
	a[1][1]=.16607303292785;
	a[2][1]=.02487932292423;
	a[3][1]=.00468636195945;
	a[4][1]=.00100162749616;
	a[5][1]=.00023200219609;
	a[6][1]=.00005681782272;
	a[7][1]=.00001449630056;
	a[8][1]=.00000381632946;
	a[9][1]=.00000102990426;
	a[10][1]=.00000028357538;
	a[11][1]=.00000007938705;
	a[12][1]=.00000002253670;
	a[13][1]=.00000000647434;
	a[14][1]=.00000000187912;
	a[15][1]=.00000000055029;
	a[16][1]=.00000000016242;
	a[17][1]=.00000000004827;
	a[18][1]=.00000000001444;
	a[19][1]=.00000000000434;
	a[20][1]=.00000000000131;
	a[21][1]=.00000000000040;
	a[22][1]=.00000000000012;
	a[23][1]=.00000000000004;
	a[24][1]=.00000000000001;
	a[0][2]=.95180889127832;
	a[1][2]=.43131131846532;
	a[2][2]=.10002250714905;
	a[3][2]=.02442415595220;
	a[4][2]=.00622512463724;
	a[5][2]=.00164078831235;
	a[6][2]=.00044407920265;
	a[7][2]=.00012277494168;
	a[8][2]=.00003453981284;
	a[9][2]=.00000985869565;
	a[10][2]=.00000284856995;
	a[11][2]=.00000083170847;
	a[12][2]=.00000024503950;
	a[13][2]=.00000007276496;
	a[14][2]=.00000002175802;
	a[15][2]=.00000000654616;
	a[16][2]=.00000000198033;
	a[17][2]=.00000000060204;
	a[18][2]=.00000000018385;
	a[19][2]=.00000000005637;
	a[20][2]=.00000000001735;
	a[21][2]=.00000000000536;
	a[22][2]=.00000000000166;
	a[23][2]=.00000000000052;
	a[24][2]=.00000000000016;
	a[25][2]=.00000000000005;
	a[26][2]=.00000000000002;
	a[0][3]=.98161027991365;
	a[1][3]=.72926806320726;
	a[2][3]=.22774714909321;
	a[3][3]=.06809083296197;
	a[4][3]=.02013701183064;
	a[5][3]=.00595478480197;
	a[6][3]=.00176769013959;
	a[7][3]=.00052748218502;
	a[8][3]=.00015827461460;
	a[9][3]=.00004774922076;
	a[10][3]=.00001447920408;
	a[11][3]=.00000441154886;
	a[12][3]=.00000135003870;
	a[13][3]=.00000041481779;
	a[14][3]=.00000012793307;
	a[15][3]=.00000003959070;
	a[16][3]=.00000001229055;
	a[17][3]=.00000000382658;
	a[18][3]=.00000000119459;
	a[19][3]=.00000000037386;
	a[20][3]=.00000000011727;
	a[21][3]=.00000000003687;
	a[22][3]=.00000000001161;
	a[23][3]=.00000000000366;
	a[24][3]=.00000000000116;
	a[25][3]=.00000000000037;
	a[26][3]=.00000000000012;
	a[27][3]=.00000000000004;
	a[28][3]=.00000000000001;
	a[0][4]=1.0640521184614;
	a[1][4]=1.0691720744981;
	a[2][4]=.41527193251768;
	a[3][4]=.14610332936222;
	a[4][4]=.04904732648784;
	a[5][4]=.01606340860396;
	a[6][4]=.00518889350790;
	a[7][4]=.00166298717324;
	a[8][4]=.00053058279969;
	a[9][4]=.00016887029251;
	a[10][4]=.00005368328059;
	a[11][4]=.00001705923313;
	a[12][4]=.00000542174374;
	a[13][4]=.00000172394082;
	a[14][4]=.00000054853275;
	a[15][4]=.00000017467795;
	a[16][4]=.00000005567550;
	a[17][4]=.00000001776234;
	a[18][4]=.00000000567224;
	a[19][4]=.00000000181313;
	a[20][4]=.00000000058012;
	a[21][4]=.00000000018579;
	a[22][4]=.00000000005955;
	a[23][4]=.00000000001911;
	a[24][4]=.00000000000614;
	a[25][4]=.00000000000197;
	a[26][4]=.00000000000063;
	a[27][4]=.00000000000020;
	a[28][4]=.00000000000007;
	a[29][4]=.00000000000002;
	a[30][4]=.00000000000001;
	a[0][5]=.97920860669175;
	a[1][5]=.08518813148683;
	a[2][5]=.00855985222013;
	a[3][5]=.00121177214413;
	a[4][5]=.00020722768531;
	a[5][5]=.00003996958691;
	a[6][5]=.00000838064065;
	a[7][5]=.00000186848945;
	a[8][5]=.00000043666087;
	a[9][5]=.00000010591733;
	a[10][5]=.00000002647892;
	a[11][5]=.00000000678700;
	a[12][5]=.00000000177654;
	a[13][5]=.00000000047342;
	a[14][5]=.00000000012812;
	a[15][5]=.00000000003514;
	a[16][5]=.00000000000975;
	a[17][5]=.00000000000274;
	a[18][5]=.00000000000077;
	a[19][5]=.00000000000022;
	a[20][5]=.00000000000006;
	a[21][5]=.00000000000002;
	a[22][5]=.00000000000001;
	a[0][6]=.95021851963952;
	a[1][6]=.29052529161433;
	a[2][6]=.05081774061716;
	a[3][6]=.00995543767280;
	a[4][6]=.00211733895031;
	a[5][6]=.00047859470550;
	a[6][6]=.00011334321308;
	a[7][6]=.00002784733104;
	a[8][6]=.00000704788108;
	a[9][6]=.00000182788740;
	a[10][6]=.00000048387492;
	a[11][6]=.00000013033842;
	a[12][6]=.00000003563769;
	a[13][6]=.00000000987174;
	a[14][6]=.00000000276586;
	a[15][6]=.00000000078279;
	a[16][6]=.00000000022354;
	a[17][6]=.00000000006435;
	a[18][6]=.00000000001866;
	a[19][6]=.00000000000545;
	a[20][6]=.00000000000160;
	a[21][6]=.00000000000047;
	a[22][6]=.00000000000014;
	a[23][6]=.00000000000004;
	a[24][6]=.00000000000001;
	a[0][7]=.95064032186777;
	a[1][7]=.54138285465171;
	a[2][7]=.13649979590321;
	a[3][7]=.03417942328207;
	a[4][7]=.00869027883583;
	a[5][7]=.00225284084155;
	a[6][7]=.00059516089806;
	a[7][7]=.00015995617766;
	a[8][7]=.00004365213096;
	a[9][7]=.00001207474688;
	a[10][7]=.00000338018176;
	a[11][7]=.00000095632476;
	a[12][7]=.00000027313129;
	a[13][7]=.00000007866968;
	a[14][7]=.00000002283195;
	a[15][7]=.00000000667205;
	a[16][7]=.00000000196191;
	a[17][7]=.00000000058018;
	a[18][7]=.00000000017246;
	a[19][7]=.00000000005151;
	a[20][7]=.00000000001545;
	a[21][7]=.00000000000465;
	a[22][7]=.00000000000141;
	a[23][7]=.00000000000043;
	a[24][7]=.00000000000013;
	a[25][7]=.00000000000004;
	a[26][7]=.00000000000001;
	a[0][8]=.98800011672229;
	a[1][8]=.04364067609601;
	a[2][8]=.00295091178278;
	a[3][8]=.00031477809720;
	a[4][8]=.00004314846029;
	a[5][8]=.00000693818230;
	a[6][8]=.00000124640350;
	a[7][8]=.00000024293628;
	a[8][8]=.00000005040827;
	a[9][8]=.00000001099075;
	a[10][8]=.00000000249467;
	a[11][8]=.00000000058540;
	a[12][8]=.00000000014127;
	a[13][8]=.00000000003492;
	a[14][8]=.00000000000881;
	a[15][8]=.00000000000226;
	a[16][8]=.00000000000059;
	a[17][8]=.00000000000016;
	a[18][8]=.00000000000004;
	a[19][8]=.00000000000001;
	a[0][9]=.95768506546350;
	a[1][9]=.19725249679534;
	a[2][9]=.02603370313918;
	a[3][9]=.00409382168261;
	a[4][9]=.00072681707110;
	a[5][9]=.00014091879261;
	a[6][9]=.00002920458914;
	a[7][9]=.00000637631144;
	a[8][9]=.00000145167850;
	a[9][9]=.00000034205281;
	a[10][9]=.00000008294302;
	a[11][9]=.00000002060784;
	a[12][9]=.00000000522823;
	a[13][9]=.00000000135066;
	a[14][9]=.00000000035451;
	a[15][9]=.00000000009436;
	a[16][9]=.00000000002543;
	a[17][9]=.00000000000693;
	a[18][9]=.00000000000191;
	a[19][9]=.00000000000053;
	a[20][9]=.00000000000015;
	a[21][9]=.00000000000004;
	a[22][9]=.00000000000001;
	a[0][10]=.99343651671347;
	a[1][10]=.02225770126826;
	a[2][10]=.00101475574703;
	a[3][10]=.00008175156250;
	a[4][10]=.00000899973547;
	a[5][10]=.00000120823987;
	a[6][10]=.00000018616913;
	a[7][10]=.00000003174723;
	a[8][10]=.00000000585215;
	a[9][10]=.00000000114739;
	a[10][10]=.00000000023652;
	a[11][10]=.00000000005082;
	a[12][10]=.00000000001131;
	a[13][10]=.00000000000259;
	a[14][10]=.00000000000061;
	a[15][10]=.00000000000015;
	a[16][10]=.00000000000004;
	a[17][10]=.00000000000001;
   
	if((n<1)||(n>4)||(m<1)||(m>4)||((n+m)>5)) return 0.;

	if(x==1.) z=s1[n][m];

	else if((x>2.)||(x<-1.))
	{
		x1=1./x;
		h=c1*x1+c2;
		alfa=h+h;
		v[0]=1.;
		v[1]=clog(-x+I*z0);
	
		for(le=2;le<=n+m;le++) v[le]=v[1]*v[le-1]/le;
       		
		sk=0.;

		for(ke=0;ke<=m-1;ke++)
		{
			m1=m-ke;
			r=pow(x1,m1)/(fct[m1]*fct[n-1]);
			sj=0.;
			for(je=0;je<=ke;je++)
			{
       				n1=n+ke-je;
       				le=index[10*n1+m1-10];
				b1=0.;
				b2=0.;
				for(it=nc[le];it>=0;it--)
				{
					b0=a[it][le]+alfa*b1-b2;
					b2=b1;
					b1=b0;
   				}
       				q=(fct[n1-1]/fct[ke-je])*(b0-h*b2)*r/pow(m1,n1);
				sj+=v[je]*q;
   			}
			sk+=sgn[ke]*sj;
   		}
		sj=0.;
		for(je=0;je<=n-1;je++) sj+=v[je]*c[n-je][m];
		z=sgn[n]*sk+sgn[m]*(sj+v[n+m]);
	}
	else if(x>hf)
	{
		x1=1.-x;
		h=c1*x1+c2;
		alfa=h+h;
		v[0]=1.;
		u[0]=1.;
		v[1]=clog(x1+I*z0);
		u[1]=clog(x);
       		for(le=2;le<=m;le++) v[le]=v[1]*v[le-1]/le;
       		for(le=2;le<=n;le++) u[le]=u[1]*u[le-1]/le;
		sk=0.;
		for(ke=0;ke<=n-1;ke++) 
		{
			m1=n-ke;
			r=pow(x1,m1)/fct[m1];
			sj=0.;
			for(je=0;je<=m-1;je++)
			{
				n1=m-je;
				le=index[10*n1+m1-10];
				b1=0;
				b2=0;
				for(it=nc[le];it>=0;it--)
 				{
					b0=a[it][le]+alfa*b1-b2;
       					b2=b1;
					b1=b0;
   				}
				q=sgn[je]*(b0-h*b2)*r/pow(m1,n1);
				sj+=v[je]*q;
   			}
			sk=sk+u[ke]*(s1[m1][m]-sj);
   		}
		z=sk+sgn[m]*u[n]*v[m];
       }
       else
       {
		le=index[10*n+m-10];
		h=c1*x+c2;
		alfa=h+h;
		b1=0;
		b2=0;
		for(it=nc[le];it>=0;it--)
		{
			b0=a[it][le]+alfa*b1-b2;
			b2=b1;
			b1=b0;
   		}
		z=(b0-h*b2)*pow(x,m)/(fct[m]*pow(m,n));
       }
       return z;
}

/*--------------------------------------------------------------------*/
/* The following functions are needed to compute complex polylogs */

double complex cd(double x, double y)
{
	return x+I*y;
}

double complex hpl_base1(int i, double complex x)
{
	if(i==0) return clog(x);
	if(i==1) return -clog(1.-x);
	return 0.;
}

double complex hpl_base2(int i1, int i2, double complex x)
{
	double complex u;
	u = clog(1.-x);

	if(i1==0&&i2==1) return 
	-1.*u - 0.25*cpow(u,2) - 0.027777777777777776*cpow(u,3) + 
	0.0002777777777777778*cpow(u,5) - 
	4.72411186696901e-6*cpow(u,7) + 
	9.185773074661964e-8*cpow(u,9) - 
	1.8978869988971e-9*cpow(u,11) + 
	4.0647616451442256e-11*cpow(u,13) - 
	8.921691020456452e-13*cpow(u,15) + 
	1.9939295860721074e-14*cpow(u,17) - 
	4.518980029619918e-16*cpow(u,19) + 
	1.0356517612181247e-17*cpow(u,21);
	
	return 0.;
}

double complex hpl_base3(int i1, int i2, int i3, double complex x)
{
	double complex  u;
	u = clog(1.-x);

	if(i1==0&&i2==0&&i3==1)
	return 
	-1.*u - 0.375*cpow(u,2) - 0.0787037037037037*cpow(u,3) - 
	0.008680555555555556*cpow(u,4) - 
	0.00012962962962962963*cpow(u,5) + 
	0.00008101851851851852*cpow(u,6) + 
	3.4193571608537595e-6*cpow(u,7) - 
	1.328656462585034e-6*cpow(u,8) - 
	8.660871756109851e-8*cpow(u,9) + 
	2.52608759553204e-8*cpow(u,10) + 
	2.144694468364065e-9*cpow(u,11) - 
	5.140110622012979e-10*cpow(u,12) - 
	5.24958211460083e-11*cpow(u,13) + 
	1.0887754406636318e-11*cpow(u,14) + 
	1.2779396094493695e-12*cpow(u,15) - 
	2.369824177308745e-13*cpow(u,16) - 
	3.104357887965462e-14*cpow(u,17) + 
	5.261758629912506e-15*cpow(u,18) + 
	7.538479549949265e-16*cpow(u,19) - 
	1.1862322577752286e-16*cpow(u,20) - 
	1.8316979965491384e-17*cpow(u,21);

	if(i1==0&&i2==1&&i3==1)
	return 
	0.25*cpow(u,2) + 0.08333333333333333*cpow(u,3) + 
	0.010416666666666666*cpow(u,4) - 
	0.00011574074074074075*cpow(u,6) + 
	2.066798941798942e-6*cpow(u,8) - 
	4.1335978835978836e-8*cpow(u,10) + 
	8.698648744945042e-10*cpow(u,12) - 
	1.887210763816962e-11*cpow(u,14) + 
	4.182042665838962e-13*cpow(u,16) - 
	9.415778600896063e-15*cpow(u,18) + 
	2.146515514069461e-16*cpow(u,20);
	
	return 0.;
}

double complex hpl_base4(int i1, int i2, int i3, int i4, double complex  x)
{
	double complex u;
	u = clog(1.-x);

	if(i1==0&&i2==0&&i3==0&&i4==1)
	return 
	-1.*u - 0.4375*cpow(u,2) - 0.11651234567901235*cpow(u,3) - 
	0.019820601851851853*cpow(u,4) - 
	0.001927932098765432*cpow(u,5) - 
	0.000031057098765432096*cpow(u,6) + 
	0.000015624009114857836*cpow(u,7) + 
	8.485123546773206e-7*cpow(u,8) - 
	2.290961660318971e-7*cpow(u,9) - 
	2.1832614218526917e-8*cpow(u,10) + 
	3.882824879172015e-9*cpow(u,11) + 
	5.446292103220332e-10*cpow(u,12) - 
	6.960805210682725e-11*cpow(u,13) - 
	1.3375737686445216e-11*cpow(u,14) + 
	1.2784852685266572e-12*cpow(u,15) + 
	3.260562858024892e-13*cpow(u,16) - 
	2.364757116861826e-14*cpow(u,17) - 
	7.923135122031162e-15*cpow(u,18) + 
	4.3452915709984186e-16*cpow(u,19) + 
	1.923627006253592e-16*cpow(u,20) - 
	7.812414333195955e-18*cpow(u,21);

	if(i1==0&&i2==1&&i3==0&&i4==1)
	return 
	0.25*cpow(u,2) + 0.1111111111111111*cpow(u,3) + 
	0.022569444444444444*cpow(u,4) + 
	0.0020833333333333333*cpow(u,5) - 
	0.000027006172839506174*cpow(u,6) - 
	0.00001984126984126984*cpow(u,7) + 
	4.527273872511968e-7*cpow(u,8) + 
	3.389987682315725e-7*cpow(u,9) - 
	7.939132443100697e-9*cpow(u,10) - 
	6.6805622361177916e-9*cpow(u,11) + 
	1.4490216610627064e-10*cpow(u,12) + 
	1.39908336457158e-10*cpow(u,13) - 
	2.7425719106565973e-12*cpow(u,14) - 
	3.032441227329819e-12*cpow(u,15) + 
	5.358569182999823e-14*cpow(u,16) + 
	6.724068599976371e-14*cpow(u,17) - 
	1.0756816626218996e-15*cpow(u,18) - 
	1.5158529016922455e-15*cpow(u,19) + 
	2.208955024323606e-17*cpow(u,20) + 
	3.460964863954937e-17*cpow(u,21);

	if(i1==0&&i2==1&&i3==1&&i4==1)
	return 
	-0.05555555555555555*cpow(u,3) - 
	0.020833333333333332*cpow(u,4) - 
	0.002777777777777778*cpow(u,5) + 
	0.00003306878306878307*cpow(u,7) - 
	6.123848716441309e-7*cpow(u,9) + 
	1.252605419272086e-8*cpow(u,11) - 
	2.6765073061369356e-10*cpow(u,13) + 
	5.871322376319437e-12*cpow(u,15) - 
	1.312013385361243e-13*cpow(u,17) + 
	2.97340376870402e-15*cpow(u,19) - 
	6.814334965299877e-17*cpow(u,21);
	
	return 0.;
}

double complex hpl1(int i, double complex x)
{
	if(i==0) return clog(x);
	if(i==1) return -clog(1.-x);
	return 0.;
}

double complex hpl2(int i1, int i2, double complex x)
{
	if(i1==0&&i2==0)
	{
		if(cabs(x)>1) return cpow(hpl1(0,1./x),2)/2.;
		if(creal(x)>.5) return cpow(hpl1(1,1. - x),2)/2.;
		return cpow(hpl_base1(0,x),2)/2.;
	}
	
	if(i1==0&&i2==1)
	{
		if(cabs(x)>1) return
		pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + cpow(pi,2)/3. - 
		cpow(hpl1(0,1./x),2)/2.;

		if(creal(x)>.5) return
		hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + cpow(pi,2)/6.;

		return hpl_base2(0,1,x);
	}
	
	if(i1==1&&i2==0)
	{
		if(cabs(x)>1) return
		pi*cd(0.,1.)*hpl1(0,1./x) - 
		hpl1(0,1./x)*(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x)) + 
		hpl2(0,1,1./x) - cpow(pi,2)/3. + cpow(hpl1(0,1./x),2)/2.;

		if(creal(x)>.5) return hpl2(0,1,1. - x) - cpow(pi,2)/6.;

		return hpl_base1(0,x)*hpl_base1(1,x) - hpl_base2(0,1,x);
	}
	
	if(i1==1&&i2==1)
	{
		if(cabs(x)>1) return cpow(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x),2)/2.;
		if(creal(x)>.5) return cpow(hpl1(0,1. - x),2)/2.;
		return cpow(hpl_base1(1,x),2)/2.;
	}
	return 0.;
}

double complex hpl3(int i1, int i2, int i3, double complex x)
{
	if(i1==0&&i2==0&&i3==0)
	{
		if(cabs(x)>1) return -cpow(hpl1(0,1./x),3)/6.;
		if(creal(x)>.5) return -cpow(hpl1(1,1. - x),3)/6.;
		return cpow(hpl_base1(0,x),3)/6.;
	}

	if(i1==0&&i2==0&&i3==1)
	{
		if(cabs(x)>1) return
		hpl3(0,0,1,1./x) - (hpl1(0,1./x)*cpow(pi,2))/3. + 
		pi*cd(0.,0.5)*cpow(hpl1(0,1./x),2) + cpow(hpl1(0,1./x),3)/6.;

		if(creal(x)>.5) return
		1.2020569031595942 + hpl1(1,1. - x)*hpl2(0,1,1. - x) - 
		hpl3(0,1,1,1. - x) - (hpl1(1,1. - x)*cpow(pi,2))/6. - 
		(hpl1(0,1. - x)*cpow(hpl1(1,1. - x),2))/2.;
		
		return hpl_base3(0,0,1,x);
	}
	
	if(i1==0&&i2==1&&i3==0)
	{
		if(cabs(x)>1) return
		-(hpl1(0,1./x)*(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.)) - 
		2.*(hpl3(0,0,1,1./x) - (hpl1(0,1./x)*cpow(pi,2))/3. + 
		pi*cd(0.,0.5)*cpow(hpl1(0,1./x),2) + 
		cpow(hpl1(0,1./x),3)/6.);

		if(creal(x)>.5) return
		-(hpl1(1,1. - x)*(hpl1(0,1. - x)*hpl1(1,1. - x) - 
		hpl2(0,1,1. - x) + cpow(pi,2)/6.)) - 
		2.*(1.2020569031595942 + hpl1(1,1. - x)*hpl2(0,1,1. - x) - 
		hpl3(0,1,1,1. - x) - (hpl1(1,1. - x)*cpow(pi,2))/6. - 
		(hpl1(0,1. - x)*cpow(hpl1(1,1. - x),2))/2.);

		return hpl_base1(0,x)*hpl_base2(0,1,x) - 2*hpl_base3(0,0,1,x);
	}
	
	if(i1==0&&i2==1&&i3==1)
	{
		if(cabs(x)>1) return
		1.2020569031595942 + pi*cd(0.,-1)*hpl2(0,1,1./x) - 
		hpl1(0,1./x)*hpl2(0,1,1./x) + hpl3(0,0,1,1./x) - 
		hpl3(0,1,1,1./x) + (hpl1(0,1./x)*cpow(pi,2))/2. + 
		cd(0.,0.16666666666666666)*cpow(pi,3) + 
		pi*cd(0.,-0.5)*cpow(hpl1(0,1./x),2) - cpow(hpl1(0,1./x),3)/6.;

		if(creal(x)>.5) return
		1.2020569031595942 + hpl1(0,1. - x)*hpl2(0,1,1. - x) - 
		hpl3(0,0,1,1. - x) - (hpl1(1,1. - x)*cpow(hpl1(0,1. - x),2))/2.;

		return hpl_base3(0,1,1,x);
	}
	
	if(i1==1&&i2==0&&i3==0)
	{
		if(cabs(x)>1) return
		hpl3(0,0,1,1./x) - (hpl1(0,1./x)*cpow(pi,2))/3. + 
		hpl1(0,1./x)*(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.) + 
		pi*cd(0.,0.5)*cpow(hpl1(0,1./x),2) + 
		((pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x))*
		cpow(hpl1(0,1./x),2))/2. + cpow(hpl1(0,1./x),3)/6.;
		
		if(creal(x)>.5) return
		1.2020569031595942 + hpl1(1,1. - x)*hpl2(0,1,1. - x) - 
		hpl3(0,1,1,1. - x) + hpl1(1,1. - x)*
		(hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + 
		cpow(pi,2)/6.) - (hpl1(1,1. - x)*cpow(pi,2))/6. - 
		hpl1(0,1. - x)*cpow(hpl1(1,1. - x),2);

		return 
		-(hpl_base1(0,x)*hpl_base2(0,1,x)) + hpl_base3(0,0,1,x) + 
		(hpl_base1(1,x)*cpow(hpl_base1(0,x),2))/2.;
	}
	
	if(i1==1&&i2==0&&i3==1)
	{
		if(cabs(x)>1) return
		(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x))*
		(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.) - 
		2.*(1.2020569031595942 + pi*cd(0.,-1)*hpl2(0,1,1./x) - 
		hpl1(0,1./x)*hpl2(0,1,1./x) + hpl3(0,0,1,1./x) - 
		hpl3(0,1,1,1./x) + (hpl1(0,1./x)*cpow(pi,2))/2. + 
		cd(0.,0.16666666666666666)*cpow(pi,3) + 
		pi*cd(0.,-0.5)*cpow(hpl1(0,1./x),2) - 
		cpow(hpl1(0,1./x),3)/6.);

		if(creal(x)>.5) return
		-(hpl1(0,1. - x)*(hpl1(0,1. - x)*hpl1(1,1. - x) - 
		hpl2(0,1,1. - x) + cpow(pi,2)/6.)) - 
		2.*(1.2020569031595942 + hpl1(0,1. - x)*hpl2(0,1,1. - x) - 
		hpl3(0,0,1,1. - x) - 
		(hpl1(1,1. - x)*cpow(hpl1(0,1. - x),2))/2.);

		return hpl_base1(1,x)*hpl_base2(0,1,x) - 2*hpl_base3(0,1,1,x);
	}
	
	if(i1==1&&i2==1&&i3==0)
	{
		if(cabs(x)>1) return
		1.2020569031595942 + pi*cd(0.,-1)*hpl2(0,1,1./x) - 
		hpl1(0,1./x)*hpl2(0,1,1./x) + hpl3(0,0,1,1./x) - 
		hpl3(0,1,1,1./x) + (hpl1(0,1./x)*cpow(pi,2))/2. + 
		cd(0.,0.16666666666666666)*cpow(pi,3) - 
		(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x))*
		(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.) + 
		pi*cd(0.,-0.5)*cpow(hpl1(0,1./x),2) - 
		cpow(hpl1(0,1./x),3)/6. - 
		(hpl1(0,1./x)*cpow(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x),2))/2.;

		if(creal(x)>.5) return
		1.2020569031595942 + hpl1(0,1. - x)*hpl2(0,1,1. - x) - 
		hpl3(0,0,1,1. - x) + hpl1(0,1. - x)*
		(hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + 
		cpow(pi,2)/6.) - hpl1(1,1. - x)*cpow(hpl1(0,1. - x),2);

		return 
		-(hpl_base1(1,x)*hpl_base2(0,1,x)) + hpl_base3(0,1,1,x) + 
		(hpl_base1(0,x)*cpow(hpl_base1(1,x),2))/2.;
	}
	
	if(i1==1&&i2==1&&i3==1)
	{
		if(cabs(x)>1) return cpow(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x),3)/6.;
		if(creal(x)>.5) return -cpow(hpl1(0,1. - x),3)/6.;
		return cpow(hpl_base1(1,x),3)/6.;
	}
	return 0.;
}

double complex hpl4(int i1, int i2, int i3, int i4, double complex x)
{
	if(i1==0&&i2==0&&i3==0&&i4==0)
	{
		if(cabs(x)>1) return cpow(hpl1(0,1./x),4)/24.;
		if(creal(x)>.5) return cpow(hpl1(1,1. - x),4)/24.;
		return cpow(hpl_base1(0,x),4)/24.;
	}
	
	if(i1==0&&i2==0&&i3==0&&i4==1)
	{
		if(cabs(x)>1) return
		-hpl4(0,0,0,1,1./x) + cpow(pi,4)/45. + 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/6. + 
		pi*cd(0.,-0.16666666666666666)*cpow(hpl1(0,1./x),3) - 
		cpow(hpl1(0,1./x),4)/24.;

		if(creal(x)>.5)	return
		-1.2020569031595942*hpl1(1,1. - x) + 
		hpl1(1,1. - x)*hpl3(0,1,1,1. - x) - hpl4(0,1,1,1,1. - x) + 
		cpow(pi,4)/90. - (hpl2(0,1,1. - x)*cpow(hpl1(1,1. - x),2))/
		2. + (cpow(pi,2)*cpow(hpl1(1,1. - x),2))/12. + 
		(hpl1(0,1. - x)*cpow(hpl1(1,1. - x),3))/6.;
		
		return hpl_base4(0,0,0,1,x);
	}
	
	if(i1==0&&i2==0&&i3==1&&i4==0)
	{
		if(cabs(x)>1) return
		-(hpl1(0,1./x)*(hpl3(0,0,1,1./x) - 
		(hpl1(0,1./x)*cpow(pi,2))/3. + 
		pi*cd(0.,0.5)*cpow(hpl1(0,1./x),2) + 
		cpow(hpl1(0,1./x),3)/6.)) - 
		3*(-hpl4(0,0,0,1,1./x) + cpow(pi,4)/45. + 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/6. + 
		pi*cd(0.,-0.16666666666666666)*cpow(hpl1(0,1./x),3) - 
		cpow(hpl1(0,1./x),4)/24.);
		
		if(creal(x)>.5) return
		-(hpl1(1,1. - x)*(1.2020569031595942 + 
		hpl1(1,1. - x)*hpl2(0,1,1. - x) - hpl3(0,1,1,1. - x) - 
		(hpl1(1,1. - x)*cpow(pi,2))/6. - 
		(hpl1(0,1. - x)*cpow(hpl1(1,1. - x),2))/2.)) - 
		3*(-1.2020569031595942*hpl1(1,1. - x) + 
		hpl1(1,1. - x)*hpl3(0,1,1,1. - x) - 
		hpl4(0,1,1,1,1. - x) + cpow(pi,4)/90. - 
		(hpl2(0,1,1. - x)*cpow(hpl1(1,1. - x),2))/2. + 
		(cpow(pi,2)*cpow(hpl1(1,1. - x),2))/12. + 
		(hpl1(0,1. - x)*cpow(hpl1(1,1. - x),3))/6.);

		return hpl_base1(0,x)*hpl_base3(0,0,1,x) - 3*hpl_base4(0,0,0,1,x);
	}

	if(i1==0&&i2==0&&i3==1&&i4==1)
	{
		if(cabs(x)>1) return
		(-2*(3.7763731361630786*cd(0.,2) + 
		2.4041138063191885*hpl1(0,1./x) + 
		pi*cd(0.,1.)*hpl1(0,1./x)*hpl2(0,1,1./x) + 
		pi*cd(0.,-2)*hpl3(0,0,1,1./x) - 
		2.*hpl1(0,1./x)*hpl3(0,0,1,1./x) + 
		4*hpl4(0,0,0,1,1./x) + hpl4(0,1,0,1,1./x) - 
		(hpl2(0,1,1./x)*cpow(pi,2))/3. + cpow(pi,4)/90. + 
		(hpl2(0,1,1./x)*cpow(hpl1(0,1./x),2))/2. - 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/6. + 
		pi*cd(0.,0.16666666666666666)*cpow(hpl1(0,1./x),3) + 
		cpow(hpl1(0,1./x),4)/24.) + 
		cpow(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.,2))/4.;

		if(creal(x)>.5) return
		(-2*(2.4041138063191885*hpl1(1,1. - x) + 
		hpl1(0,1. - x)*hpl1(1,1. - x)*hpl2(0,1,1. - x) - 
		hpl4(0,1,0,1,1. - x) + 
		(hpl1(0,1. - x)*hpl1(1,1. - x)*cpow(pi,2))/6. - 
		(hpl2(0,1,1. - x)*cpow(pi,2))/6. + cpow(pi,4)/120. + 
		cpow(hpl2(0,1,1. - x),2) - 
		2.*(hpl1(1,1. - x)*hpl3(0,0,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - cpow(hpl2(0,1,1. - x),2))/
		2. + (-2*hpl4(0,1,0,1,1. - x) + 
		cpow(hpl2(0,1,1. - x),2))/2.) - 
		2.*(hpl1(0,1. - x)*hpl3(0,1,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - cpow(hpl2(0,1,1. - x),2))/
		2. + (-2*hpl4(0,1,0,1,1. - x) + 
		cpow(hpl2(0,1,1. - x),2))/2.)) + 
		cpow(hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + 
		cpow(pi,2)/6.,2))/4.;

		return (-2*hpl_base4(0,1,0,1,x) + cpow(hpl_base2(0,1,x),2))/4.;
	}
	
	if(i1==0&&i2==1&&i3==0&&i4==0)
	{
		if(cabs(x)>1) return
		((pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + cpow(pi,2)/3. - 
		cpow(hpl1(0,1./x),2)/2.)*cpow(hpl1(0,1./x),2) + 
		4*hpl1(0,1./x)*(hpl3(0,0,1,1./x) - 
		(hpl1(0,1./x)*cpow(pi,2))/3. + 
		pi*cd(0.,0.5)*cpow(hpl1(0,1./x),2) + 
		cpow(hpl1(0,1./x),3)/6.) + 
		6*(-hpl4(0,0,0,1,1./x) + cpow(pi,4)/45. + 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/6. + 
		pi*cd(0.,-0.16666666666666666)*cpow(hpl1(0,1./x),3) - 
		cpow(hpl1(0,1./x),4)/24.))/2.;

		if(creal(x)>.5) return
		((hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + 
		cpow(pi,2)/6.)*cpow(hpl1(1,1. - x),2) + 
		4*hpl1(1,1. - x)*(1.2020569031595942 + 
		hpl1(1,1. - x)*hpl2(0,1,1. - x) - hpl3(0,1,1,1. - x) - 
		(hpl1(1,1. - x)*cpow(pi,2))/6. - 
		(hpl1(0,1. - x)*cpow(hpl1(1,1. - x),2))/2.) + 
		6*(-1.2020569031595942*hpl1(1,1. - x) + 
		hpl1(1,1. - x)*hpl3(0,1,1,1. - x) - 
		hpl4(0,1,1,1,1. - x) + cpow(pi,4)/90. - 
		(hpl2(0,1,1. - x)*cpow(hpl1(1,1. - x),2))/2. + 
		(cpow(pi,2)*cpow(hpl1(1,1. - x),2))/12. + 
		(hpl1(0,1. - x)*cpow(hpl1(1,1. - x),3))/6.))/2.;

		return 
		(-4*hpl_base1(0,x)*hpl_base3(0,0,1,x) + 6*hpl_base4(0,0,0,1,x) + 
		hpl_base2(0,1,x)*cpow(hpl_base1(0,x),2))/2.;
	}
	
	if(i1==0&&i2==1&&i3==0&&i4==1)
	{
		if(cabs(x)>1) return
		3.7763731361630786*cd(0.,2) + 
		2.4041138063191885*hpl1(0,1./x) + 
		pi*cd(0.,1.)*hpl1(0,1./x)*hpl2(0,1,1./x) + 
		pi*cd(0.,-2)*hpl3(0,0,1,1./x) - 
		2.*hpl1(0,1./x)*hpl3(0,0,1,1./x) + 4*hpl4(0,0,0,1,1./x) + 
		hpl4(0,1,0,1,1./x) - (hpl2(0,1,1./x)*cpow(pi,2))/3. + 
		cpow(pi,4)/90. + (hpl2(0,1,1./x)*cpow(hpl1(0,1./x),2))/2. - 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/6. + 
		pi*cd(0.,0.16666666666666666)*cpow(hpl1(0,1./x),3) + 
		cpow(hpl1(0,1./x),4)/24.;

		if(creal(x)>.5) return
		2.4041138063191885*hpl1(1,1. - x) + 
		hpl1(0,1. - x)*hpl1(1,1. - x)*hpl2(0,1,1. - x) - 
		hpl4(0,1,0,1,1. - x) + 
		(hpl1(0,1. - x)*hpl1(1,1. - x)*cpow(pi,2))/6. - 
		(hpl2(0,1,1. - x)*cpow(pi,2))/6. + cpow(pi,4)/120. + 
		cpow(hpl2(0,1,1. - x),2) - 
		2.*(hpl1(1,1. - x)*hpl3(0,0,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + cpow(hpl2(0,1,1. - x),2))/2.)\
		- 2*(hpl1(0,1. - x)*hpl3(0,1,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + cpow(hpl2(0,1,1. - x),2))/2.);

		return hpl_base4(0,1,0,1,x);
	}
	
	if(i1==0&&i2==1&&i3==1&&i4==0)
	{
		if(cabs(x)>1) return
		3.7763731361630786*cd(0.,-2) - 
		2.4041138063191885*hpl1(0,1./x) + 
		pi*cd(0.,-1)*hpl1(0,1./x)*hpl2(0,1,1./x) + 
		pi*cd(0.,2)*hpl3(0,0,1,1./x) + 
		2.*hpl1(0,1./x)*hpl3(0,0,1,1./x) - 4*hpl4(0,0,0,1,1./x) - 
		hpl4(0,1,0,1,1./x) + (hpl2(0,1,1./x)*cpow(pi,2))/3. - 
		cpow(pi,4)/90. - (hpl2(0,1,1./x)*cpow(hpl1(0,1./x),2))/2. + 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/6. - 
		hpl1(0,1./x)*(1.2020569031595942 + 
		pi*cd(0.,-1)*hpl2(0,1,1./x) - 
		hpl1(0,1./x)*hpl2(0,1,1./x) + hpl3(0,0,1,1./x) - 
		hpl3(0,1,1,1./x) + (hpl1(0,1./x)*cpow(pi,2))/2. + 
		cd(0.,0.16666666666666666)*cpow(pi,3) + 
		pi*cd(0.,-0.5)*cpow(hpl1(0,1./x),2) - 
		cpow(hpl1(0,1./x),3)/6.) + 
		pi*cd(0.,-0.16666666666666666)*cpow(hpl1(0,1./x),3) - 
		cpow(hpl1(0,1./x),4)/24. + 
		(2.*(3.7763731361630786*cd(0.,2) + 
		2.4041138063191885*hpl1(0,1./x) + 
		pi*cd(0.,1.)*hpl1(0,1./x)*hpl2(0,1,1./x) + 
		pi*cd(0.,-2)*hpl3(0,0,1,1./x) - 
		2.*hpl1(0,1./x)*hpl3(0,0,1,1./x) + 
		4*hpl4(0,0,0,1,1./x) + hpl4(0,1,0,1,1./x) - 
		(hpl2(0,1,1./x)*cpow(pi,2))/3. + cpow(pi,4)/90. + 
		(hpl2(0,1,1./x)*cpow(hpl1(0,1./x),2))/2. - 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/6. + 
		pi*cd(0.,0.16666666666666666)*cpow(hpl1(0,1./x),3) + 
		cpow(hpl1(0,1./x),4)/24.) - 
		cpow(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.,2))/2.;

		if(creal(x)>.5) return
		-2.4041138063191885*hpl1(1,1. - x) - 
		hpl1(0,1. - x)*hpl1(1,1. - x)*hpl2(0,1,1. - x) + 
		hpl4(0,1,0,1,1. - x) - 
		(hpl1(0,1. - x)*hpl1(1,1. - x)*cpow(pi,2))/6. + 
		(hpl2(0,1,1. - x)*cpow(pi,2))/6. - cpow(pi,4)/120. - 
		hpl1(1,1. - x)*(1.2020569031595942 + 
		hpl1(0,1. - x)*hpl2(0,1,1. - x) - hpl3(0,0,1,1. - x) - 
		(hpl1(1,1. - x)*cpow(hpl1(0,1. - x),2))/2.) - 
		cpow(hpl2(0,1,1. - x),2) + 
		2.*(hpl1(1,1. - x)*hpl3(0,0,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + cpow(hpl2(0,1,1. - x),2))/2.)\
		+ 2*(hpl1(0,1. - x)*hpl3(0,1,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + cpow(hpl2(0,1,1. - x),2))/2.)\
		+ (2.*(2.4041138063191885*hpl1(1,1. - x) + 
		hpl1(0,1. - x)*hpl1(1,1. - x)*hpl2(0,1,1. - x) - 
		hpl4(0,1,0,1,1. - x) + 
		(hpl1(0,1. - x)*hpl1(1,1. - x)*cpow(pi,2))/6. - 
		(hpl2(0,1,1. - x)*cpow(pi,2))/6. + cpow(pi,4)/120. + 
		cpow(hpl2(0,1,1. - x),2) - 
		2.*(hpl1(1,1. - x)*hpl3(0,0,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - 
		cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + 
		cpow(hpl2(0,1,1. - x),2))/2.) - 
		2.*(hpl1(0,1. - x)*hpl3(0,1,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - 
		cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + 
		cpow(hpl2(0,1,1. - x),2))/2.)) - 
		cpow(hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + 
		cpow(pi,2)/6.,2))/2.;

		return 
		hpl_base1(0,x)*hpl_base3(0,1,1,x) - hpl_base4(0,1,0,1,x) + 
   		(2.*hpl_base4(0,1,0,1,x) - cpow(hpl_base2(0,1,x),2))/2.;
	}
	
	if(i1==0&&i2==1&&i3==1&&i4==1)
	{
		if(cabs(x)>1) return
		pi*cd(0.,-1)*hpl1(0,1./x)*hpl2(0,1,1./x) + 
		pi*cd(0.,1.)*hpl3(0,0,1,1./x) + 
		hpl1(0,1./x)*hpl3(0,0,1,1./x) + 
		pi*cd(0.,-1)*hpl3(0,1,1,1./x) - 
		hpl1(0,1./x)*hpl3(0,1,1,1./x) - hpl4(0,0,0,1,1./x) - 
		hpl4(0,1,0,1,1./x)/2. - hpl4(0,1,1,1,1./x) + 
		(hpl2(0,1,1./x)*cpow(pi,2))/2. + 
		cd(0.,0.16666666666666666)*hpl1(0,1./x)*cpow(pi,3) - 
		(19*cpow(pi,4))/360. - 
		(hpl2(0,1,1./x)*cpow(hpl1(0,1./x),2))/2. + 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/4. + 
		pi*cd(0.,-0.16666666666666666)*cpow(hpl1(0,1./x),3) - 
		cpow(hpl1(0,1./x),4)/24. + 
		(2.*hpl4(0,1,0,1,1./x) - cpow(hpl2(0,1,1./x),2))/2. + 
		cpow(hpl2(0,1,1./x),2)/4. + 
		(-2*hpl4(0,1,0,1,1./x) + cpow(hpl2(0,1,1./x),2))/2.;

		if(creal(x)>.5) return
		hpl1(0,1. - x)*hpl3(0,0,1,1. - x) - hpl4(0,0,0,1,1. - x) + 
		cpow(pi,4)/90. - (hpl2(0,1,1. - x)*cpow(hpl1(0,1. - x),2))/
		2. + (hpl1(1,1. - x)*cpow(hpl1(0,1. - x),3))/6.;

		return hpl_base4(0,1,1,1,x);
	}
	
	if(i1==1&&i2==0&&i3==0&&i4==0)
	{
		if(cabs(x)>1) return
		(-3*(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.)*
		cpow(hpl1(0,1./x),2) - 
		6*hpl1(0,1./x)*(hpl3(0,0,1,1./x) - 
		(hpl1(0,1./x)*cpow(pi,2))/3. + 
		pi*cd(0.,0.5)*cpow(hpl1(0,1./x),2) + 
		cpow(hpl1(0,1./x),3)/6.) - 
		(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x))*
		cpow(hpl1(0,1./x),3) - 
		6*(-hpl4(0,0,0,1,1./x) + cpow(pi,4)/45. + 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/6. + 
		pi*cd(0.,-0.16666666666666666)*cpow(hpl1(0,1./x),3) - 
		cpow(hpl1(0,1./x),4)/24.))/6.;

		if(creal(x)>.5) return
		(-3*(hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + 
		cpow(pi,2)/6.)*cpow(hpl1(1,1. - x),2) - 
		6*hpl1(1,1. - x)*(1.2020569031595942 + 
		hpl1(1,1. - x)*hpl2(0,1,1. - x) - hpl3(0,1,1,1. - x) - 
		(hpl1(1,1. - x)*cpow(pi,2))/6. - 
		(hpl1(0,1. - x)*cpow(hpl1(1,1. - x),2))/2.) + 
		hpl1(0,1. - x)*cpow(hpl1(1,1. - x),3) - 
		6*(-1.2020569031595942*hpl1(1,1. - x) + 
		hpl1(1,1. - x)*hpl3(0,1,1,1. - x) - 
		hpl4(0,1,1,1,1. - x) + cpow(pi,4)/90. - 
		(hpl2(0,1,1. - x)*cpow(hpl1(1,1. - x),2))/2. + 
		(cpow(pi,2)*cpow(hpl1(1,1. - x),2))/12. + 
		(hpl1(0,1. - x)*cpow(hpl1(1,1. - x),3))/6.))/6.;

		return 
		(6*hpl_base1(0,x)*hpl_base3(0,0,1,x) - 6*hpl_base4(0,0,0,1,x) - 
		3*hpl_base2(0,1,x)*cpow(hpl_base1(0,x),2) + hpl_base1(1,x)*cpow(hpl_base1(0,x),3))/6.;
	}
	
	if(i1==1&&i2==0&&i3==0&&i4==1)
	{
		if(cabs(x)>1) return
		3.7763731361630786*cd(0.,-2) - 
		2.4041138063191885*hpl1(0,1./x) + 
		pi*cd(0.,-1)*hpl1(0,1./x)*hpl2(0,1,1./x) + 
		pi*cd(0.,2)*hpl3(0,0,1,1./x) + 
		2.*hpl1(0,1./x)*hpl3(0,0,1,1./x) - 4*hpl4(0,0,0,1,1./x) - 
		hpl4(0,1,0,1,1./x) + (hpl2(0,1,1./x)*cpow(pi,2))/3. - 
		cpow(pi,4)/90. - (hpl2(0,1,1./x)*cpow(hpl1(0,1./x),2))/2. + 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/6. + 
		(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x))*
		(hpl3(0,0,1,1./x) - (hpl1(0,1./x)*cpow(pi,2))/3. + 
		pi*cd(0.,0.5)*cpow(hpl1(0,1./x),2) + 
		cpow(hpl1(0,1./x),3)/6.) + 
		pi*cd(0.,-0.16666666666666666)*cpow(hpl1(0,1./x),3) - 
		cpow(hpl1(0,1./x),4)/24. + 
		(2.*(3.7763731361630786*cd(0.,2) + 
		2.4041138063191885*hpl1(0,1./x) + 
		pi*cd(0.,1.)*hpl1(0,1./x)*hpl2(0,1,1./x) + 
		pi*cd(0.,-2)*hpl3(0,0,1,1./x) - 
		2.*hpl1(0,1./x)*hpl3(0,0,1,1./x) + 
		4*hpl4(0,0,0,1,1./x) + hpl4(0,1,0,1,1./x) - 
		(hpl2(0,1,1./x)*cpow(pi,2))/3. + cpow(pi,4)/90. + 
		(hpl2(0,1,1./x)*cpow(hpl1(0,1./x),2))/2. - 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/6. + 
		pi*cd(0.,0.16666666666666666)*cpow(hpl1(0,1./x),3) + 
		cpow(hpl1(0,1./x),4)/24.) - 
		cpow(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.,2))/2.;

		if(creal(x)>.5) return
		-2.4041138063191885*hpl1(1,1. - x) - 
		hpl1(0,1. - x)*hpl1(1,1. - x)*hpl2(0,1,1. - x) + 
		hpl4(0,1,0,1,1. - x) - 
		(hpl1(0,1. - x)*hpl1(1,1. - x)*cpow(pi,2))/6. + 
		(hpl2(0,1,1. - x)*cpow(pi,2))/6. - cpow(pi,4)/120. - 
		hpl1(0,1. - x)*(1.2020569031595942 + 
		hpl1(1,1. - x)*hpl2(0,1,1. - x) - hpl3(0,1,1,1. - x) - 
		(hpl1(1,1. - x)*cpow(pi,2))/6. - 
		(hpl1(0,1. - x)*cpow(hpl1(1,1. - x),2))/2.) - 
		cpow(hpl2(0,1,1. - x),2) + 
		2.*(hpl1(1,1. - x)*hpl3(0,0,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + cpow(hpl2(0,1,1. - x),2))/2.)\
		+ 2*(hpl1(0,1. - x)*hpl3(0,1,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + cpow(hpl2(0,1,1. - x),2))/2.)\
		+ (2.*(2.4041138063191885*hpl1(1,1. - x) + 
		hpl1(0,1. - x)*hpl1(1,1. - x)*hpl2(0,1,1. - x) - 
		hpl4(0,1,0,1,1. - x) + 
		(hpl1(0,1. - x)*hpl1(1,1. - x)*cpow(pi,2))/6. - 
		(hpl2(0,1,1. - x)*cpow(pi,2))/6. + cpow(pi,4)/120. + 
		cpow(hpl2(0,1,1. - x),2) - 
		2.*(hpl1(1,1. - x)*hpl3(0,0,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - 
		cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + 
		cpow(hpl2(0,1,1. - x),2))/2.) - 
		2.*(hpl1(0,1. - x)*hpl3(0,1,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - 
		cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + 
		cpow(hpl2(0,1,1. - x),2))/2.)) - 
		cpow(hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + 
		cpow(pi,2)/6.,2))/2.;

		return hpl_base1(1,x)*hpl_base3(0,0,1,x) - hpl_base4(0,1,0,1,x) + 
		(2.*hpl_base4(0,1,0,1,x) - cpow(hpl_base2(0,1,x),2))/2.;
	}
	
	if(i1==1&&i2==0&&i3==1&&i4==0)
	{
		if(cabs(x)>1) return
		3.7763731361630786*cd(0.,-2) - 
		2.4041138063191885*hpl1(0,1./x) + 
		pi*cd(0.,-1)*hpl1(0,1./x)*hpl2(0,1,1./x) + 
		pi*cd(0.,2)*hpl3(0,0,1,1./x) + 
		2.*hpl1(0,1./x)*hpl3(0,0,1,1./x) - 4*hpl4(0,0,0,1,1./x) - 
		hpl4(0,1,0,1,1./x) + (hpl2(0,1,1./x)*cpow(pi,2))/3. - 
		cpow(pi,4)/90. - hpl1(0,1./x)*
		(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x))*
		(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.) - 
		(hpl2(0,1,1./x)*cpow(hpl1(0,1./x),2))/2. + 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/6. + 
		2.*hpl1(0,1./x)*(1.2020569031595942 + 
		pi*cd(0.,-1)*hpl2(0,1,1./x) - 
		hpl1(0,1./x)*hpl2(0,1,1./x) + hpl3(0,0,1,1./x) - 
		hpl3(0,1,1,1./x) + (hpl1(0,1./x)*cpow(pi,2))/2. + 
		cd(0.,0.16666666666666666)*cpow(pi,3) + 
		pi*cd(0.,-0.5)*cpow(hpl1(0,1./x),2) - 
		cpow(hpl1(0,1./x),3)/6.) - 
		2.*(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x))*
		(hpl3(0,0,1,1./x) - (hpl1(0,1./x)*cpow(pi,2))/3. + 
		pi*cd(0.,0.5)*cpow(hpl1(0,1./x),2) + 
		cpow(hpl1(0,1./x),3)/6.) + 
		pi*cd(0.,-0.16666666666666666)*cpow(hpl1(0,1./x),3) - 
		cpow(hpl1(0,1./x),4)/24. + 
		cpow(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.,2);

		if(creal(x)>.5) return
		-2.4041138063191885*hpl1(1,1. - x) - 
		hpl1(0,1. - x)*hpl1(1,1. - x)*hpl2(0,1,1. - x) + 
		hpl4(0,1,0,1,1. - x) + 
		hpl1(0,1. - x)*hpl1(1,1. - x)*
		(hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + 
		cpow(pi,2)/6.) - (hpl1(0,1. - x)*hpl1(1,1. - x)*
		cpow(pi,2))/6. + (hpl2(0,1,1. - x)*cpow(pi,2))/6. - 
		cpow(pi,4)/120. + 2*hpl1(1,1. - x)*
		(1.2020569031595942 + hpl1(0,1. - x)*hpl2(0,1,1. - x) - 
		hpl3(0,0,1,1. - x) - 
		(hpl1(1,1. - x)*cpow(hpl1(0,1. - x),2))/2.) + 
		2.*hpl1(0,1. - x)*(1.2020569031595942 + 
		hpl1(1,1. - x)*hpl2(0,1,1. - x) - hpl3(0,1,1,1. - x) - 
		(hpl1(1,1. - x)*cpow(pi,2))/6. - 
		(hpl1(0,1. - x)*cpow(hpl1(1,1. - x),2))/2.) - 
		cpow(hpl2(0,1,1. - x),2) + 
		2.*(hpl1(1,1. - x)*hpl3(0,0,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + cpow(hpl2(0,1,1. - x),2))/2.)\
		+ 2*(hpl1(0,1. - x)*hpl3(0,1,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + cpow(hpl2(0,1,1. - x),2))/2.)\
		+ cpow(hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + 
		cpow(pi,2)/6.,2);
		
		return 
		hpl_base1(0,x)*hpl_base1(1,x)*hpl_base2(0,1,x) - 2*hpl_base1(1,x)*hpl_base3(0,0,1,x) - 
		2.*hpl_base1(0,x)*hpl_base3(0,1,1,x) - hpl_base4(0,1,0,1,x) + 
		cpow(hpl_base2(0,1,x),2);
	}
	
	if(i1==1&&i2==0&&i3==1&&i4==1)
	{
		if(cabs(x)>1) return
		(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x))*
		(1.2020569031595942 + pi*cd(0.,-1)*hpl2(0,1,1./x) - 
		hpl1(0,1./x)*hpl2(0,1,1./x) + hpl3(0,0,1,1./x) - 
		hpl3(0,1,1,1./x) + (hpl1(0,1./x)*cpow(pi,2))/2. + 
		cd(0.,0.16666666666666666)*cpow(pi,3) + 
		pi*cd(0.,-0.5)*cpow(hpl1(0,1./x),2) - 
		cpow(hpl1(0,1./x),3)/6.) - 
		3*(pi*cd(0.,-1)*hpl1(0,1./x)*hpl2(0,1,1./x) + 
		pi*cd(0.,1.)*hpl3(0,0,1,1./x) + 
		hpl1(0,1./x)*hpl3(0,0,1,1./x) + 
		pi*cd(0.,-1)*hpl3(0,1,1,1./x) - 
		hpl1(0,1./x)*hpl3(0,1,1,1./x) - hpl4(0,0,0,1,1./x) - 
		hpl4(0,1,0,1,1./x)/2. - hpl4(0,1,1,1,1./x) + 
		(hpl2(0,1,1./x)*cpow(pi,2))/2. + 
		cd(0.,0.16666666666666666)*hpl1(0,1./x)*cpow(pi,3) - 
		(19*cpow(pi,4))/360. - 
		(hpl2(0,1,1./x)*cpow(hpl1(0,1./x),2))/2. + 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/4. + 
		pi*cd(0.,-0.16666666666666666)*cpow(hpl1(0,1./x),3) - 
		cpow(hpl1(0,1./x),4)/24. + 
		(2.*hpl4(0,1,0,1,1./x) - cpow(hpl2(0,1,1./x),2))/2. + 
		cpow(hpl2(0,1,1./x),2)/4. + 
		(-2*hpl4(0,1,0,1,1./x) + cpow(hpl2(0,1,1./x),2))/2.);

		if(creal(x)>.5) return
		-(hpl1(0,1. - x)*(1.2020569031595942 + 
		hpl1(0,1. - x)*hpl2(0,1,1. - x) - hpl3(0,0,1,1. - x) - 
		(hpl1(1,1. - x)*cpow(hpl1(0,1. - x),2))/2.)) - 
		3*(hpl1(0,1. - x)*hpl3(0,0,1,1. - x) - 
		hpl4(0,0,0,1,1. - x) + cpow(pi,4)/90. - 
		(hpl2(0,1,1. - x)*cpow(hpl1(0,1. - x),2))/2. + 
		(hpl1(1,1. - x)*cpow(hpl1(0,1. - x),3))/6.);

		return hpl_base1(1,x)*hpl_base3(0,1,1,x) - 3*hpl_base4(0,1,1,1,x);
	}
	
	if(i1==1&&i2==1&&i3==0&&i4==0)
	{
		if(cabs(x)>1) return
		hpl1(0,1./x)*(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x))*
		(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.) - 
		hpl1(0,1./x)*(1.2020569031595942 + 
		pi*cd(0.,-1)*hpl2(0,1,1./x) - 
		hpl1(0,1./x)*hpl2(0,1,1./x) + hpl3(0,0,1,1./x) - 
		hpl3(0,1,1,1./x) + (hpl1(0,1./x)*cpow(pi,2))/2. + 
		cd(0.,0.16666666666666666)*cpow(pi,3) + 
		pi*cd(0.,-0.5)*cpow(hpl1(0,1./x),2) - 
		cpow(hpl1(0,1./x),3)/6.) + 
		(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x))*
		(hpl3(0,0,1,1./x) - (hpl1(0,1./x)*cpow(pi,2))/3. + 
		pi*cd(0.,0.5)*cpow(hpl1(0,1./x),2) + 
		cpow(hpl1(0,1./x),3)/6.) + 
		(cpow(hpl1(0,1./x),2)*cpow(pi*cd(0.,1.) + hpl1(0,1./x) + 
		hpl1(1,1./x),2))/4. + 
		(2.*(3.7763731361630786*cd(0.,2) + 
		2.4041138063191885*hpl1(0,1./x) + 
		pi*cd(0.,1.)*hpl1(0,1./x)*hpl2(0,1,1./x) + 
		pi*cd(0.,-2)*hpl3(0,0,1,1./x) - 
		2.*hpl1(0,1./x)*hpl3(0,0,1,1./x) + 
		4*hpl4(0,0,0,1,1./x) + hpl4(0,1,0,1,1./x) - 
		(hpl2(0,1,1./x)*cpow(pi,2))/3. + cpow(pi,4)/90. + 
		(hpl2(0,1,1./x)*cpow(hpl1(0,1./x),2))/2. - 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/6. + 
		pi*cd(0.,0.16666666666666666)*cpow(hpl1(0,1./x),3) + 
		cpow(hpl1(0,1./x),4)/24.) - 
		cpow(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.,2))/4.;

		if(creal(x)>.5) return
		-(hpl1(0,1. - x)*hpl1(1,1. - x)*
		(hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + 
		cpow(pi,2)/6.)) - 
		hpl1(1,1. - x)*(1.2020569031595942 + 
		hpl1(0,1. - x)*hpl2(0,1,1. - x) - hpl3(0,0,1,1. - x) - 
		(hpl1(1,1. - x)*cpow(hpl1(0,1. - x),2))/2.) + 
		(cpow(hpl1(0,1. - x),2)*cpow(hpl1(1,1. - x),2))/4. - 
		hpl1(0,1. - x)*(1.2020569031595942 + 
		hpl1(1,1. - x)*hpl2(0,1,1. - x) - hpl3(0,1,1,1. - x) - 
		(hpl1(1,1. - x)*cpow(pi,2))/6. - 
		(hpl1(0,1. - x)*cpow(hpl1(1,1. - x),2))/2.) + 
		(2.*(2.4041138063191885*hpl1(1,1. - x) + 
		hpl1(0,1. - x)*hpl1(1,1. - x)*hpl2(0,1,1. - x) - 
		hpl4(0,1,0,1,1. - x) + 
		(hpl1(0,1. - x)*hpl1(1,1. - x)*cpow(pi,2))/6. - 
		(hpl2(0,1,1. - x)*cpow(pi,2))/6. + cpow(pi,4)/120. + 
		cpow(hpl2(0,1,1. - x),2) - 
		2.*(hpl1(1,1. - x)*hpl3(0,0,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - 
		cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + 
		cpow(hpl2(0,1,1. - x),2))/2.) - 
		2.*(hpl1(0,1. - x)*hpl3(0,1,1,1. - x) + 
		(2.*hpl4(0,1,0,1,1. - x) - 
		cpow(hpl2(0,1,1. - x),2))/2. + 
		(-2*hpl4(0,1,0,1,1. - x) + 
		cpow(hpl2(0,1,1. - x),2))/2.)) - 
		cpow(hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + 
		cpow(pi,2)/6.,2))/4.;

		return 
		-(hpl_base1(0,x)*hpl_base1(1,x)*hpl_base2(0,1,x)) + hpl_base1(1,x)*hpl_base3(0,0,1,x) +
		hpl_base1(0,x)*hpl_base3(0,1,1,x) + 
		(cpow(hpl_base1(0,x),2)*cpow(hpl_base1(1,x),2))/4. + 
		(2.*hpl_base4(0,1,0,1,x) - cpow(hpl_base2(0,1,x),2))/4.;
	}
	
	if(i1==1&&i2==1&&i3==0&&i4==1)
	{
		if(cabs(x)>1) return
		(-4*(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x))*
		(1.2020569031595942 + pi*cd(0.,-1)*hpl2(0,1,1./x) - 
		hpl1(0,1./x)*hpl2(0,1,1./x) + hpl3(0,0,1,1./x) - 
		hpl3(0,1,1,1./x) + (hpl1(0,1./x)*cpow(pi,2))/2. + 
		cd(0.,0.16666666666666666)*cpow(pi,3) + 
		pi*cd(0.,-0.5)*cpow(hpl1(0,1./x),2) - 
		cpow(hpl1(0,1./x),3)/6.) + 
		(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.)*
		cpow(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x),2) + 
		6*(pi*cd(0.,-1)*hpl1(0,1./x)*hpl2(0,1,1./x) + 
		pi*cd(0.,1.)*hpl3(0,0,1,1./x) + 
		hpl1(0,1./x)*hpl3(0,0,1,1./x) + 
		pi*cd(0.,-1)*hpl3(0,1,1,1./x) - 
		hpl1(0,1./x)*hpl3(0,1,1,1./x) - hpl4(0,0,0,1,1./x) - 
		hpl4(0,1,0,1,1./x)/2. - hpl4(0,1,1,1,1./x) + 
		(hpl2(0,1,1./x)*cpow(pi,2))/2. + 
		cd(0.,0.16666666666666666)*hpl1(0,1./x)*cpow(pi,3) - 
		(19*cpow(pi,4))/360. - 
		(hpl2(0,1,1./x)*cpow(hpl1(0,1./x),2))/2. + 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/4. + 
		pi*cd(0.,-0.16666666666666666)*cpow(hpl1(0,1./x),3) - 
		cpow(hpl1(0,1./x),4)/24. + 
		(2.*hpl4(0,1,0,1,1./x) - cpow(hpl2(0,1,1./x),2))/2. + 
		cpow(hpl2(0,1,1./x),2)/4. + 
		(-2*hpl4(0,1,0,1,1./x) + cpow(hpl2(0,1,1./x),2))/2.))/2.;

		if(creal(x)>.5) return
		((hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + 
		cpow(pi,2)/6.)*cpow(hpl1(0,1. - x),2) + 
		4*hpl1(0,1. - x)*(1.2020569031595942 + 
		hpl1(0,1. - x)*hpl2(0,1,1. - x) - hpl3(0,0,1,1. - x) - 
		(hpl1(1,1. - x)*cpow(hpl1(0,1. - x),2))/2.) + 
		6*(hpl1(0,1. - x)*hpl3(0,0,1,1. - x) - 
		hpl4(0,0,0,1,1. - x) + cpow(pi,4)/90. - 
		(hpl2(0,1,1. - x)*cpow(hpl1(0,1. - x),2))/2. + 
		(hpl1(1,1. - x)*cpow(hpl1(0,1. - x),3))/6.))/2.;

		return 
		(-4*hpl_base1(1,x)*hpl_base3(0,1,1,x) + 6*hpl_base4(0,1,1,1,x) + 
		hpl_base2(0,1,x)*cpow(hpl_base1(1,x),2))/2.;
	}
	
	if(i1==1&&i2==1&&i3==1&&i4==0)
	{
		if(cabs(x)>1) return
		(6*(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x))*
		(1.2020569031595942 + pi*cd(0.,-1)*hpl2(0,1,1./x) - 
		hpl1(0,1./x)*hpl2(0,1,1./x) + hpl3(0,0,1,1./x) - 
		hpl3(0,1,1,1./x) + (hpl1(0,1./x)*cpow(pi,2))/2. + 
		cd(0.,0.16666666666666666)*cpow(pi,3) + 
		pi*cd(0.,-0.5)*cpow(hpl1(0,1./x),2) - 
		cpow(hpl1(0,1./x),3)/6.) - 
		3*(pi*cd(0.,-1)*hpl1(0,1./x) - hpl2(0,1,1./x) + 
		cpow(pi,2)/3. - cpow(hpl1(0,1./x),2)/2.)*
		cpow(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x),2) - 
		hpl1(0,1./x)*cpow(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x),
		3) - 6*(pi*cd(0.,-1)*hpl1(0,1./x)*hpl2(0,1,1./x) + 
		pi*cd(0.,1.)*hpl3(0,0,1,1./x) + 
		hpl1(0,1./x)*hpl3(0,0,1,1./x) + 
		pi*cd(0.,-1)*hpl3(0,1,1,1./x) - 
		hpl1(0,1./x)*hpl3(0,1,1,1./x) - hpl4(0,0,0,1,1./x) - 
		hpl4(0,1,0,1,1./x)/2. - hpl4(0,1,1,1,1./x) + 
		(hpl2(0,1,1./x)*cpow(pi,2))/2. + 
		cd(0.,0.16666666666666666)*hpl1(0,1./x)*cpow(pi,3) - 
		(19*cpow(pi,4))/360. - 
		(hpl2(0,1,1./x)*cpow(hpl1(0,1./x),2))/2. + 
		(cpow(pi,2)*cpow(hpl1(0,1./x),2))/4. + 
		pi*cd(0.,-0.16666666666666666)*cpow(hpl1(0,1./x),3) - 
		cpow(hpl1(0,1./x),4)/24. + 
		(2.*hpl4(0,1,0,1,1./x) - cpow(hpl2(0,1,1./x),2))/2. + 
		cpow(hpl2(0,1,1./x),2)/4. + 
		(-2*hpl4(0,1,0,1,1./x) + cpow(hpl2(0,1,1./x),2))/2.))/6.;

		if(creal(x)>.5) return
		(-3*(hpl1(0,1. - x)*hpl1(1,1. - x) - hpl2(0,1,1. - x) + 
		cpow(pi,2)/6.)*cpow(hpl1(0,1. - x),2) - 
		6*hpl1(0,1. - x)*(1.2020569031595942 + 
		hpl1(0,1. - x)*hpl2(0,1,1. - x) - hpl3(0,0,1,1. - x) - 
		(hpl1(1,1. - x)*cpow(hpl1(0,1. - x),2))/2.) + 
		hpl1(1,1. - x)*cpow(hpl1(0,1. - x),3) - 
		6*(hpl1(0,1. - x)*hpl3(0,0,1,1. - x) - 
		hpl4(0,0,0,1,1. - x) + cpow(pi,4)/90. - 
		(hpl2(0,1,1. - x)*cpow(hpl1(0,1. - x),2))/2. + 
		(hpl1(1,1. - x)*cpow(hpl1(0,1. - x),3))/6.))/6.;

		return 
		(6*hpl_base1(1,x)*hpl_base3(0,1,1,x) - 6*hpl_base4(0,1,1,1,x) - 
		3*hpl_base2(0,1,x)*cpow(hpl_base1(1,x),2) + hpl_base1(0,x)*cpow(hpl_base1(1,x),3))/6.;
	}
	
	if(i1==1&&i2==1&&i3==1&&i4==1)
	{
		if(cabs(x)>1) return cpow(pi*cd(0.,1.) + hpl1(0,1./x) + hpl1(1,1./x),4)/24.;
		if(creal(x)>.5) return cpow(hpl1(0,1. - x),4)/24.;
		return cpow(hpl_base1(1,x),4)/24.;
	}
	return 0.;
}

/*--------------------------------------------------------------------*/

double Li2(double x)
/* calculates the dilogarithm function of x */
{
	double pisq6=pow((4.*atan(1.)),2.)/6.;
	double x_0 = -0.3;
	double x_1 = 0.25;
	double x_2 = 0.51;
	if (x == 1.) return pisq6;
	if (x <= x_0)
	{ 
		double temp = log(fabs(1.-x));
		return -Li2(-x/(1.-x)) - temp*temp/2. ; 
	}
	else if (x < x_1)
	{
		double z = - log(1.-x);
		double temp = z*(1.-z/4.*(1.-z/9.*(1.-z*z/100.*(1.-5.*z*z/294.*(1.-7.*z*z/360.*(1.-5.*z*z/242.*(1.-7601.*z*z/354900.*(1.-91.*z*z/4146.*(1.-3617.*z*z/161840.)))))))));
		return temp; 
	}
	else if (x < x_2) return - Li2(-x) + Li2(x*x)/2. ;
	else 
	{ 
		return pisq6 - Li2(1.-x) - log(fabs(x))*log(fabs(1.-x)) ; 
	}
}

/*--------------------------------------------------------------------*/

double Li3(double x)
/* calculates the trilogarithm function of x */
{
	double pisq6=16.*pow(atan(1.),2.)/6.;
	double x_0 = -1.;
	double x_1 = -0.85;
	double x_2 = 0.25;
	double x_3 = 0.63;
	double x_4 =  1.;
	if (x == 1.) return zeta3;
	if (x == -1.) return - 0.75 * zeta3;
	if (x <= x_0)
	{ 
		double lnx = log(-x);
		return Li3(1./x) - pisq6*lnx - lnx*lnx*lnx/6.;
	}
	else if (x < x_1)
	{
		return Li3(x*x)/4. - Li3(-x);
	}
	else if (x < x_2)
	{
		double z = - log(1.-x);
		double temp = z*(1.-3.*z/8.*(1.-17.*z/81.*(1.-15.*z/136.
		*(1.-28.*z/1875.*(1.+5.*z/8.*(1.-304.*z/7203.
		*(1.+945.*z/2432.*(1.-44.*z/675.*(1.+7.*z/24.
		*(1.-26104.*z/307461.*(1.+1925.*z/8023.
		*(1.-53598548.*z/524808375.
		*(1.+22232925.*z/107197096.
		)))))))))))));
		return temp; 
	}
	else if (x < x_3)
	{
		return Li3(x*x)/4. - Li3(-x);
	}
	else if (x < x_4)
	{
		double ln1x = log(1.-x); 
		return -Li3(1.-x) - Li3(-x/(1.-x)) + zeta3 + pisq6*ln1x - log(x)*ln1x*ln1x/2. + ln1x*ln1x*ln1x/6.; 
	}
	else 
	{ 
		double lnx = log(x);
		return Li3(1./x) + 2.*pisq6*lnx - lnx*lnx*lnx/6.;
	}
}

/*--------------------------------------------------------------------*/

double Li4(double x)
/* calculates the quadrilogarithm function of x */
{
	return polylog(3,1,x);
}

/*--------------------------------------------------------------------*/

double complex CLi2(double complex x)
/* calculates the dilogarithm function of x, extended to complex numbers */
{
	double pisq6=pow((4.*atan(1.)),2.)/6.;

	double x_0 = -0.30;
	double x_1 = 0.25;
	double x_2 = 0.51;
	if (x == 1.) return pisq6;
	if (creal(x) >= x_2) 
	{ 
		return pisq6 - CLi2(1.-x) - clog(x)*clog(1.-x);
	}
	if ((fabs(cimag(x)) > 1.) || (creal(x)*creal(x) + cimag(x)*cimag(x) > 1.2))
	{
		return - CLi2(1./x) - 0.5 * clog(-x) * clog(-x) - pisq6;
	}
	if (creal(x) <= x_0)
	{ 
		double complex zz = clog(1.-x);
		return -CLi2(-x/(1.-x)) - zz*zz/2. ;
	}
 	else if (creal(x) < x_1)
	{
		double complex z = - clog(1.-x);
		double complex temp = z*(1.-z/4.*(1.-z/9.*(1.-z*z/100.
		*(1.-5.*z*z/294.*(1.-7.*z*z/360.
		*(1.-5.*z*z/242.*(1.-7601.*z*z/354900.
		*(1.-91.*z*z/4146.*(1.-3617.*z*z/161840.)))))))));
		return temp;
	}
		else return - CLi2(-x) + CLi2(x*x)/2.;
}

/*--------------------------------------------------------------------*/

double complex CLi3(double complex x)
/* calculates the trilogarithm function of x, extended to complex numbers */
{
	return hpl3(0,0,1,x);
}
/*--------------------------------------------------------------------*/

double complex CLi4(double complex x)
/* calculates the quadrilogarithm function of x, extended to complex numbers */
{
	return hpl4(0,0,0,1,x);
}

/*--------------------------------------------------------------------*/

double Cl2(double x)
/* calculates the Cl2 function of x */
{
	return cimag(CLi2(cos(x)+I*sin(x)));
}

/*--------------------------------------------------------------------*/

double Cl3(double x)
/* calculates the Cl3 function of x */
{
	return creal(CLi3(cos(x)+I*sin(x)));
}

/*--------------------------------------------------------------------*/

double max(double x, double y)
{
	if(x<y) return y; else return x;
}

/*--------------------------------------------------------------------*/

double min(double x, double y)
{
	if(x<y) return x; else return y;
}

/*-----------------------------------------------------------------------*/
/* Modified Bessel functions of second type and of order 0,1,2 */
/*-----------------------------------------------------------------------*/

double I0(double x)
/* calculates the Modified Bessel functions of first type and of order 0 of x */
{
	double y;

	double absx=fabs(x);

	if (absx < 3.75) 
	{
		y=x/3.75;
		y=y*y;
		return 1.+y*(3.5156229+y*(3.0899424+y*(1.2067492+y*(0.2659732+y*(0.360768e-1+y*0.45813e-2)))));
 	} 
	else
	{
		y=3.75/absx;
		return (exp(absx)/sqrt(absx))*(0.39894228+y*(0.1328592e-1+y*(0.225319e-2+y*(-0.157565e-2+y*(0.916281e-2+y*(-0.2057706e-1+y*(0.2635537e-1+y*(-0.1647633e-1+y*0.392377e-2))))))));
 	}
}

double I1(double x)
/* calculates the Modified Bessel functions of first type and of order 1 of x */
{
	double y,tmp;
	double I1=0.;

	double absx=fabs(x);

	if (absx < 3.75) 
	{
		y=x/3.75;
		y=y*y;
				I1 = absx*(0.5+y*(0.87890594+y*(0.51498869+y*(0.15084934+y*(0.2658733e-1+y*(0.301532e-2+y*0.32411e-3))))));
	}
	else
	{
		y=3.75/absx;
	  		tmp=0.2282967e-1+y*(-0.2895312e-1+y*(0.1787654e-1-y*0.420059e-2));
				tmp=0.39894228+y*(-0.3988024e-1+y*(-0.362018e-2+y*(0.163801e-2+y*(-0.1031555e-1+y*tmp))));
				I1*=(exp(absx)/sqrt(absx));
	}
	if(x<0.) return -I1; else return I1;
}

double K0(double x)
/* calculates the Modified Bessel functions of second type and of order 0 of x */
{
	double y;

	if (x <= 2.) 
	{
		y=x*x/4.;
		return (-log(x/2.)*I0(x))+(-0.57721566+y*(0.42278420+y*(0.23069756+y*(0.3488590e-1+y*(0.262698e-2+y*(0.10750e-3+y*0.74e-5))))));
	} 
	else 
	{
		y=2./x;
				return (exp(-x)/sqrt(x))*(1.25331414+y*(-0.7832358e-1+y*(0.2189568e-1+y*(-0.1062446e-1+y*(0.587872e-2+y*(-0.251540e-2+y*0.53208e-3))))));
		}
}

double K1(double x)
/* calculates the Modified Bessel functions of second type and of order 1 of x */
{
 	double y;

	if (x <= 2.) 
	{
		y=x*x/4.;
		return (log(x/2.)*I1(x))+(1./x)*(1.+y*(0.15443144+y*(-0.67278579+y*(-0.18156897+y*(-0.1919402e-1+y*(-0.110404e-2+y*(-0.4686e-4)))))));
	}
	else 
	{
		y=2./x;
		return (exp(-x)/sqrt(x))*(1.25331414+y*(0.23498619+y*(-0.3655620e-1+y*(0.1504268e-1+y*(-0.780353e-2+y*(0.325614e-2+y*(-0.68245e-3)))))));
		}
}

double K2(double x)
/* calculates the Modified Bessel functions of second type and of order 2 of x */
{
	return K0(x)+2./x*K1(x);
}

double K3(double x)
/* calculates the Modified Bessel functions of second type and of order 3 of x */
{
	return K1(x)+4./x*K2(x);
}

double K4(double x)
/* calculates the Modified Bessel functions of second type and of order 4 of x */
{
	return K2(x)+6./x*K3(x);
}

double Lbessel(double x)
/* calculates L(x)=K2(x)/x */
{
	return K2(x)/x;
}

double Mbessel(double x)
/* calculates M(x)=(3*K3(x)+K1(x))/4x */
{
	return (0.75*K3(x)+0.25*K1(x))/x;
}

double Nbessel(double x)
/* calculates N(x)=(K4(x)+K2(x))/2x */
{
	return (0.5*K4(x)+0.5*K2(x))/x;
}

double K0exp(double x, double z)
/* calculates the extended Modified Bessel functions of second type and of order 0 of x and z */
{
	double y;

	if (x <= 2.) 
	{
		y=x*x/4.;
		return ((-log(x/2.)*I0(x))+(-0.57721566+y*(0.42278420+y*(0.23069756+y*(0.3488590e-1+y*(0.262698e-2+y*(0.10750e-3+y*0.74e-5)))))))*exp(z)*sqrt(z);
	} 
	else 
	{
		y=2./x;
				return (exp(z-x)/sqrt(x/z))*(1.25331414+y*(-0.7832358e-1+y*(0.2189568e-1+y*(-0.1062446e-1+y*(0.587872e-2+y*(-0.251540e-2+y*0.53208e-3))))));
	}
}

double K1exp(double x,double z)
/* calculates the extended Modified Bessel functions of second type and of order 1 of x and z */
{
 	double y;

	if (x <= 2.) 
	{
		y=x*x/4.;
		return ((log(x/2.)*I1(x))+(1./x)*(1.+y*(0.15443144+y*(-0.67278579+y*(-0.18156897+y*(-0.1919402e-1+y*(-0.110404e-2+y*(-0.4686e-4))))))))*exp(z)*sqrt(z);
	}
	else 
	{
		y=2./x;
		return (exp(z-x)/sqrt(x/z))*(1.25331414+y*(0.23498619+y*(-0.3655620e-1+y*(0.1504268e-1+y*(-0.780353e-2+y*(0.325614e-2+y*(-0.68245e-3)))))));
	}
}

double K2exp(double x,double z)
/* calculates the extended Modified Bessel functions of second type and of order 2 of x and z */
{
	return K0exp(x,z)+2./x*K1exp(x,z);
}

/*--------------------------------------------------------------------*/

double expcor(double x)
/* calculates the exponential of x, with limited extension */
{
	if(x>100.) return exp(100.);
	else if(x<-100.) return 0.;
	else return exp(x);
}

/*--------------------------------------------------------------------*/

double kron(int x, int y)
/* kronecker symbol */
{
	if(x==y) return 1.; else return 0.;
}

/*--------------------------------------------------------------------*/

int test_integer(char name[])
/* tests if the string "name" is an integer, and return 1 if so, 0 otherwise */
{
	char *testint;
	strtol(name,&testint,10);
	return (*testint=='\0');
}

/*--------------------------------------------------------------------*/

int test_file(char *name)
{
/* tests if the file "name" exist, and return 1 if so, 0 otherwise */
	struct stat buffer;
	return (stat(name,&buffer) == 0);
}

/*--------------------------------------------------------------------*/

int invert_matrix(int n, double** in, double** out)
/* matrix inversion, input matrix of size n x n, output of the same size */
{
    int ie,je,ke;
	double ratio,a;
	
	double** matrix; /* matrix of size 2n * 2n */
	double* matrixtemp;
	matrix = malloc(2*n * sizeof(double*));
	matrixtemp = malloc(2*n * 2*n * sizeof(double));
	for (ie = 0; ie < 2*n; ie++) matrix[ie] = matrixtemp + (ie * 2*n);

	char dummy[20];
	for(ie=0;ie<n;ie++) for(je=0;je<n;je++) 
	{
		sprintf(dummy,"%.4e\n",in[ie][je]);
		in[ie][je]=matrix[ie][je]=atof(dummy);
	}
 
  
    for(ie=0;ie<n;ie++) for(je=n;je<2*n;je++) if(ie==(je-n)) matrix[ie][je]=1.; else matrix[ie][je]=0.;
    
    for(ie=0;ie<n;ie++) for(je=0;je<n;je++) if(ie!=je)
	{
		ratio=matrix[je][ie]/matrix[ie][ie];
		for(ke=0;ke<2*n;ke++) matrix[je][ke]-=ratio*matrix[ie][ke];
	}

    for(ie=0;ie<n;ie++)
    {
		a=matrix[ie][ie];
		for(je=0;je<2*n;je++) matrix[ie][je]/=a;
    }

    for(ie=0;ie<n;ie++) for(je=n;je<2*n;je++) out[ie][je-n]=matrix[ie][je];

	/* check invertion */
	int test=1;
	double product[n][n];
	for(ie=0;ie<n;ie++) for(je=0;je<n;je++) product[ie][je]=0.;
	for(ie=0;ie<n;ie++) for(je=0;je<n;je++) for(ke=0;ke<n;ke++) product[ie][je]+=in[ie][ke]*out[ke][je];

	for(ie=0;ie<n;ie++) if(fabs(product[ie][je]-(ie==je))<1.e-2) test*=1; else test=0;
	
	if(test==0) return 0; else return 1;
}

/*--------------------------------------------------------------------*/

double rand_gauss()
/* Gaussian generation of random numbers centered on 0 with a variance 1 */
{
	double rsq=0.;
	double v1,v2;

	while((rsq==0.)||(rsq>=1.))
	{
		v1=2.*rand()/(RAND_MAX+1.)-1.;
		v2=2.*rand()/(RAND_MAX+1.)-1.;
		rsq=v1*v1+v2*v2;
	}
	double fac=sqrt(-2.*log(rsq)/rsq);
	return v1*fac;
}

/*--------------------------------------------------------------------*/

double myrand(int type, int on)
/* type: 1 -> Gaussian centered on 0 with variance 1, 2 -> flat between -1 and +1
   on: if on==0 return 0 or if on==-1 return 1 */
{
	if(on==0) return 0.;
	else if(on==-1) return 1.;
	 
	if(type==2) return -1.+2.*rand()/(RAND_MAX+1.);
	else return rand_gauss();
}

/*--------------------------------------------------------------------*/
/* Cholesky decomposition, inspired by http://rosettacode.org/wiki/Cholesky_decomposition#C */
int cholesky(int n, double** in, double** out)
{
	int ie,je,ke;
	double s;
	int test=1;
	
	for(ie=0;ie<n;ie++) for(je=0;je<n;je++) out[ie][je]=0.;
	
    for(ie=0;ie<n;ie++) for(je=0;je<(ie+1);je++) 
    {
		s=0.;
		for (ke=0;ke<je;ke++) s+=out[ie][ke]*out[je][ke];
        if(in[ie][ie]-s<0.) test=0;
        if(ie==je) out[ie][je]=sqrt(fabs(in[ie][ie]-s));
        else out[ie][je]=(1./out[je][je]*(in[ie][je]-s));
    }

    if(test==0)
    {
		printf("Cholesky decomposition: WARNING! input matrix not (well) positive definite...\n");
		printf("Basic regularisation applied\n");
		printf("Check that the matrix elements below is close enough to zero...\n");
	
	    double reconstructed[n][n];
	    for(ie=0;ie<n;ie++) for(je=0;je<n;je++) reconstructed[ie][je]=0.;
		for(ie=0;ie<n;ie++) for(je=0;je<n;je++) for(ke=0;ke<n;ke++) reconstructed[ie][je]+=out[ie][ke]*out[je][ke];
	    
		printf("reconstructed_matrix-input_matrix=\n");
		for(ie=0;ie<n;ie++) 
		{
			for(je=0;je<n;je++) printf("%f  ",reconstructed[ie][je]-in[ie][je]);
			printf("\n");
		}
		printf("\n");
	}
	   
    return test;
}

/*--------------------------------------------------------------------*/

double interpol_fromtable(double val, double table[], int dim, int order)
/* lagrangian interpolation to get f(val) with 0<val<1 in a table of f(i) of dimension "dim"+1 */ 
{
	if(order<1) order=1;
	int xi[order+1];
	double x=val*dim;
	double li[order+1];
	int ie,je;
	
	int low=round(x)-order+1;
	if(low<0) low=0;
	if(low+order>=dim) low=dim-order;
	
	for(ie=0;ie<order+1;ie++) xi[ie]=low+ie;
	for(ie=0;ie<order+1;ie++) li[ie]=1.;
	for(ie=0;ie<order+1;ie++) for(je=0;je<order+1;je++) {if(ie!=je) li[ie]*=(x-(double)xi[je])/((double)xi[ie]-(double)xi[je]);}
	double res=0.;
	for(ie=0;ie<order+1;ie++) res+=table[xi[ie]]*li[ie];
	
	return res;
}

/*----------------------------------------------------------------------*/

double simpson_noerr(double *f, double *x, int n1, int n2)
{
	double res1=0.;
	double delta=(x[n2]-x[n1])/((double)(n2-n1));
	int i;
	double fact;

	for(i=n1;i<=n2;i++)
	{
		if(i==n1||i==n2) fact=1.;
		else if(i&1) fact=4.;
		else fact=2.;
		res1+=fact*f[i];
	}

	res1*=delta/3.;
	return res1;
}

/*--------------------------------------------------------------------*/

void simpson_rec(double (*func)(double), double *f, double *x, int *n, int n1, int n2, double *restot, double err)
{
	int Nmax=500;
	int i;

	if((*n)<Nmax&&(n1<n2)&&n2<=*n)
	{
		double res4=simpson_noerr(f,x,n1,n2);
		double xn2=x[n2];
		double xn1=x[n1];

		for(i=(*n);i>n2; i--)
		{
			x[i+4]=x[i];
			f[i+4]=f[i];
		}
		*n+=4;
		n2+=4;

		double delta=(xn2-xn1)/((double)(n2-n1));

		for(i=n2;i>=n1; i--)
		{
			if(!(i&1))
			{
				x[i]=x[(i+n1)/2];
				f[i]=f[(i+n1)/2];
			}
			else
			{
				x[i]=x[n1]+(i-n1)*delta;
				f[i]=func(x[i]);
			}
		}

		double res8=simpson_noerr(f,x,n1,n2);
		double err0;
		if(*restot==0) err0=fabs(res8-res4);
		else err0=fabs((res8-res4)/(*restot));
		*restot+=(res8-res4);

		if(err0>err) 
		{
			int n0=(*n);
			simpson_rec(func,f,x, n,n1,n1+4,restot,err);
			int dn=*n-n0;
			for(i=dn+n1+4;i<=*n; i++)
			{
				x[i-dn-4]=x[i];
				f[i-dn-4]=f[i];
			}
			*n-=dn+4;
			simpson_rec(func,f,x,n, n1,n1+4,restot,err);
		}
	}
	
	return;
}

/*--------------------------------------------------------------------*/

double simpson(double (*func)(double), double a, double b, double err)
{
	int n=4;
	double * f=malloc(500*sizeof(double));
	double * x=malloc(500*sizeof(double));
	int i;
	double delta=(b-a)/((double)n);
	for(i=0;i<=n; i++)
	{
		x[i]=a+i*delta;
		f[i]=(*func)(a+i*delta);
	}
	double restot=simpson_noerr(f,x,0,n);
	simpson_rec(func,f,x, &n,0,n,&restot,err);
	free(f);
	free(x);

	return restot;
}

/*--------------------------------------------------------------------*/

void brentzero(double (*func)(double), double a, double b, double *fmin, double *xmin, double eps)
{
	double fa=func(a);
	double fb=func(b);
	double tmp;
	double delta=1.0e-4;

	if(fa*fb>=0) return;
	if(fabs(fa)<fabs(fb))
	{
		a=tmp;
		a=b;
		b=tmp;
	}
	double c= a;
	double fc=fa;
	double s,d,fs;
	int mflag=1;

	do
	{
		if (fa !=fc && fb !=fc) s=a*fb*fc/(fa-fb)/(fa-fc) +b*fa*fc/(fb-fa)/(fb-fc)+c*fa*fb/(fc-fa)/(fc-fb);
		else s=b-fb*(b-a)/(fb-fa);

		int cond1=(b<=s&&s<=(3*a+b)/4.) && (b>=s&&s>=(3*a+b)/4.);
		int cond2= mflag&& fabs(s-b)>=fabs(b-c)/2.;
		int cond3= !mflag&& fabs(s-b)>=fabs(c-d)/2.;
		int cond4= mflag&& fabs(b-c)<delta;
		int cond5= !mflag&& fabs(c-d)<delta;

		if(cond1||cond2||cond3||cond4||cond5)
		{
			s=(a + b)/2. ;
			mflag=1;
		}
		else mflag=0;
		
		fs=func(s);
		d = c;
		c = b;
		if(fa*fs < 0) b=s;
		else a=s;
		if(fabs(fa)<fabs(fb))
		{
			tmp=a;
			a=b;
			b=tmp;
		}
	}
	while( fb*fs!=0 && fabs(b-a)>eps);

	*fmin=fs;
	*xmin=s;
	
	return;
}

/*--------------------------------------------------------------------*/

void braket(int n, double (*func)(double[]), double* a0, double*x0, double*b0, double xinit[], double xi[], double xlimmin[], double xlimmax[], double factor)
{
	int BRAKETMAX=50;
	int nmax=5;

	int i;
	double a0tmp,b0tmp;
	
	double xr,xrand[nmax],frand;
	double xa[nmax], xb[nmax];
	double fa,fb,fmin;

/*	*a0=-1.0e+99;*/
/*	*b0=1.0e+99;*/
	int afirst=1;
	int bfirst=1;
	for(i=0;i<n;i++)
	{
		if(xi[i]!=0)
		{
			a0tmp=(xlimmin[i]-xinit[i])/xi[i];
			b0tmp=(xlimmax[i]-xinit[i])/xi[i];
			
			if(a0tmp>*a0||afirst) {*a0=a0tmp; afirst=0;}
			if(b0tmp<*b0||bfirst) {*b0=b0tmp; bfirst=0;}
		}	
	}
	
	if(*a0>*b0)
	{
		*a0=0;
		*b0=0;
		*x0=0;
	}
	else
	{ 
		for(i=0;i<n;i++)
		{
			xa[i]=xinit[i]+*a0*xi[i];
			xb[i]=xinit[i]+*b0*xi[i];
		}
		fa=factor*func(xa);
		fb=factor*func(xb);
		if(fa<fb)
		{ 
			*x0=*a0;
			fmin=fa;
		}
		else
		{
			*x0=*b0;
			fmin=fb;
		}
		int irand;
		
		int icount=0;
		for(irand=0;irand<BRAKETMAX;irand++)
		{
			xr=*a0+irand*(*b0-*a0)/BRAKETMAX;
			for(i=0;i<n;i++)xrand[i]=xinit[i]+xr*xi[i];
			frand=factor*func(xrand);
			if(frand<fmin)
			{
				*x0=xr;
				fmin=frand;
				icount++;
			}
			if(icount==5) break;
		}
	}
	
	return;
}

/*--------------------------------------------------------------------*/

int brentmethod(int n, double (*func)(double[]), double xmin[], double xi[], double xlimmin[], double xlimmax[], double *fmin, double factor)
//minimize function func along vector xi
{
	double a0,b0,x0, xmin1d;
	double xitemp[n];
	int i;

	braket(n,func,&a0,&x0,&b0,xmin,xi,xlimmin,xlimmax,factor);
	
	int test=brentmethod1D(func,a0,  x0, b0, fmin, &xmin1d, factor, xmin, xi, n);
	for(i=0;i<n; i++) xmin[i]=xmin[i]+xmin1d*xi[i];
	
	return test;
}

/*--------------------------------------------------------------------*/

double brentmethod1Dfunc(double (*func)(double[]), double x, double xmini[], double xi[], int n)
{
	int i;
	double xitemp[n];
	
	for(i=0;i<n;i++) xitemp[i]=xmini[i]+x*xi[i];
	
	return func(xitemp);
}

int brentmethod1D(double (*func)(double[]), double a0, double x0,double b0, double *fmin, double *xmin, double factor, double xmini[], double xi[], int n)
{	
	int BrentIterMax=1000;
	double ZEPS=1.0e-70;
	double CGOLD=0.1;
	double tol=1.0e-3;

	double tol1, tol2;
	double a,b;
	
	if(a0<b0)
	{
		a=a0;
		b=b0;
	}
	else
	{
		a=b0;
		b=a0;
	}
	
	double x,w,v; // points used in the parabolic fit
	double u;
	double  pa1, pa2; // parabola parameters pa2*X^2+pa1*X+pa0
	double pamin; // parabola minimum 
	double xm;
	double fx,fw,fv, fu;
	double e=0, etmp,d;
	int iter=0;
	
	x=w=v=x0;
	fx=fw=fv=factor*brentmethod1Dfunc(func,x0,xmini,xi,n);
	xm=0.5*(a+b);
	
	do
	{
		tol1=tol*fabs(x)+ZEPS ;
		tol2=e*tol1;

		if (fabs(e)>tol1)
		{
			pa2=((fw-fx)/(w-x)-(fv-fx)/(v-x))/(w-v); // parabolic fit
			pa1=(fv-fx)/(v-x) -pa2*(v+x);
			pamin=-0.5*pa1/pa2;
			etmp=e;
			e=d;
			if(fabs(x-pamin)>0.5*etmp||pamin<a||pamin>b)
			{// cannot use the parabolic fit
				if(x>=xm) e=a-x;
				else e=b-x;
				d=CGOLD*e;
			}
			else
			{
				d=pamin-x;
				u=pamin;
				if((u-a)<tol2||(b-u)<tol2)
				{// pamin too close to borders
					d=fabs(tol1);
					if(xm<x) d=-d;
				}
			}
		}
		else
		{
			if(x>=xm) e=a-x;
			else e=b-x;
			d=CGOLD*e;
		}	
		
		if(fabs(d)>=tol1) u=x+d;
		else
		{
			if(d<0) u=x-fabs(tol1);
			else u=x+fabs(tol1);
		}
		fu=factor*brentmethod1Dfunc(func,u,xmini,xi,n);

		if(fu<=fx)
		{
			if(u>=x) a=x;
			else b=x;
			v=w;w=x;x=u;
			fv=fw;fw=fx;fx=fu;
		}
		else
		{
			if(u<x) a=u;
			else b=u;
			if(fu<=fw||w==x)
			{
				v=w;
				w=u;
				fv=fw;
				fw=fu;
			}
			else if(fu<=fv||v==x||v==w)
			{
				v=u;
				fv=fu;
			}
		}

		xm=0.5*(a+b);

		iter++;
	}
	while(iter<BrentIterMax&&fabs(x-xm)+0.5*(b-a)> 2*tol1);
	
	*xmin=x;
	*fmin=fx;

	if(iter==BrentIterMax)
	{
		printf("WARNING: too many iterations in Brent's method, precision decreased\n");
		return 0;
	}
	else return 1;
}

/*----------------------------------------------------------------*/
#define debug 0

int powellaux(int n, double (*func)(double[]), double x0[], double xlimmin[], double xlimmax[], double* fmin,  double xmin[], double ftol, double factor)
{	
	double TINY=1.0e-70;
	int ITMAX=500;
	int nmax=5;

	int i,j,iter;
	double vect[nmax][nmax];
	//initiate set of vectors
	
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			if(i==j) vect[i][j]=1;
			else vect[i][j]=0;
		}
	}	

	for(j=0;j<n;j++) xmin[j]=x0[j]; // initiate minimum position

	double vecti[nmax];// current vector in the iteration
	double fmintemp;
	int imax;
	double fdeltamax;
	*fmin=factor*func(x0);
	double fiter, xiter[nmax];
	int testbrent; 
	
	double meanvect[nmax], xextrapol[nmax];

	double fextrapol;
	double t;
	
	for(iter=0;iter<=ITMAX;iter++)
	{
			
		fiter=*fmin;
		for(j=0;j<n;j++) xiter[j]=xmin[j];
		fdeltamax=0;
		for(i=0;i<n;i++)
		{
			for(j=0;j<n;j++) vecti[j]=vect[j][i];
			fmintemp=*fmin;
			testbrent=brentmethod(n,func,xmin,vecti,xlimmin,xlimmax,fmin,factor);
			if(testbrent==0)
			{
				if(debug) printf("Brent method unsuccessful\n");
				return 0;
			}

			if((fmintemp-*fmin)>fdeltamax)
			{
				imax=i;
				fdeltamax=fmintemp-*fmin;	
			}
		}


		if(2.*(fiter-(*fmin)) <= ftol*(fabs(fiter)+fabs(*fmin))+TINY) return 0;
		
		if (iter == ITMAX)
		{
			if(debug) printf("Powell exceeding maximum iterations.\n");
			return 0;
		}
		
		for (j=0;j<n;j++)
		{ //check if it is worth to keep the mean deplacement vector
			meanvect[j]=xmin[j]-xiter[j]; 
			xextrapol[j]=xmin[j]+meanvect[j];
		}

		fextrapol=factor*func(xextrapol);
		if (fextrapol < fiter)
		{
			t=2.*(fiter-2.*(*fmin)+fextrapol)*pow(fiter-(*fmin)-fdeltamax,2.)-fdeltamax*pow(fiter-fextrapol,2.); 

			if (t < 0.)
			{
				brentmethod(n,func,xmin,meanvect, xlimmin, xlimmax, fmin, factor);
				vect[j][imax]=vect[j][n]; 
				vect[j][n]=meanvect[j];
			}
		}

	}
	
	return 1;
}


/*--------------------------------------------------------------------*/

int powell(int n, double (*func)(double[]), double xlimmin[], double xlimmax[], double* fmin, double xmin[], double ftol, char* option)
{
	int nmax=5;
	
	srand((unsigned int)time(NULL));
	double x0[nmax];
	int i;

	double factor=0.;
	if(strcmp(option,"min")==0) factor=1.;
	else if (strcmp(option,"max")==0) factor=-1.;

	for(i=0;i<n;i++) x0[i]=(xlimmin[i]+xlimmax[i])/2.;
	int test=powellaux(n,func,x0,xlimmin, xlimmax, fmin,  xmin, ftol, factor);
	if(!strcmp(option, "max")) *fmin=-*fmin; 
	
	return test;
}



